{
  "sections": {
    "& CONTROL": {
      "sectionType": "namelist",
      "variables": {
        "calculation": {
          "name": "calculation",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "String",
          "default": "'scf'",
          "description": "A string describing the task to be performed. Options are: (vc = variable-cell).",
          "options": [
            "'scf'",
            "'nscf'",
            "'bands'",
            "'relax'",
            "'md'",
            "'vc-relax'",
            "'vc-md'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "A string describing the task to be performed. Options are: (vc = variable-cell)."
        },
        "title": {
          "name": "title",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "String",
          "default": "' '",
          "description": "reprinted on output.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "reprinted on output."
        },
        "verbosity": {
          "name": "verbosity",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "String",
          "default": "'low'",
          "description": "Currently two verbosity levels are implemented: 'debug' and 'medium' have the same effect as 'high'; 'default' and 'minimal' as 'low'",
          "options": [
            "'high'",
            "'low'",
            "'debug'",
            "'medium'",
            "'default'",
            "'minimal'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Currently two verbosity levels are implemented: 'debug' and 'medium' have the same effect as 'high'; 'default' and 'minimal' as 'low'"
        },
        "restart_mode": {
          "name": "restart_mode",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "String",
          "default": "'from_scratch'",
          "description": "Available options are: From scratch. This is the normal way to perform a PWscf calculation From previous interrupted run. Use this switch only if you want to continue, using the same number of processors and parallelization, an interrupted calculation. Do not use to start a new one, or to perform a non-scf calculations. Works only if the calculation was cleanly stopped using variable max_seconds , or by user request with an \"exit file\" (i.e.: create a file \"prefix\".EXIT, in directory \"outdir\"; see variables prefix , outdir ). The default for startingwfc and startingpot is set to 'file'.",
          "options": [
            "'from_scratch'",
            "'restart'",
            "'file'"
          ],
          "units": "directory",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Available options are: From scratch. This is the normal way to perform a PWscf calculation From previous interrupted run. Use this switch only if you want to continue, using the same number of processors and parallelization, an interrupted calculation. Do not use to start a new one, or to perform a non-scf calculations. Works only if the calculation was cleanly stopped using variable max_seconds , or by user request with an \"exit file\" (i.e.: create a file \"prefix\".EXIT, in directory \"outdir\"; see variables prefix , outdir ). The default for startingwfc and startingpot is set to 'file'."
        },
        "wf_collect": {
          "name": "wf_collect",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": null,
          "description": "OBSOLETE - NO LONGER IMPLEMENTED",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "OBSOLETE - NO LONGER IMPLEMENTED"
        },
        "nstep": {
          "name": "nstep",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "1 if calculation == 'scf', 'nscf', 'bands'; 50 for the other cases",
          "description": "number of molecular-dynamics or structural optimization steps performed in this run. If set to 0, the code performs a quick \"dry run\", stopping just after initialization. This is useful to check for input correctness and to have the summary printed. NOTE: in MD calculations, the code will perform \"nstep\" steps even if restarting from a previously interrupted calculation.",
          "options": [],
          "units": "this",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "number of molecular-dynamics or structural optimization steps performed in this run. If set to 0, the code performs a quick \"dry run\", stopping just after initialization. This is useful to check for input correctness and to have the summary printed. NOTE: in MD calculations, the code will perform \"nstep\" steps even if restarting from a previously interrupted calculation."
        },
        "iprint": {
          "name": "iprint",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "write only at convergence",
          "description": "When calculation == 'md' (molecular dynamics) trajectory is written every iprint md steps.",
          "options": [
            "'md'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "When calculation == 'md' (molecular dynamics) trajectory is written every iprint md steps."
        },
        "tstress": {
          "name": "tstress",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".false.",
          "description": "calculate stress. It is set to .TRUE. automatically if calculation == 'vc-md' or 'vc-relax'",
          "options": [
            "'vc-md'",
            "'vc-relax'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "calculation == 'vc-md'"
            ]
          },
          "rawText": "calculate stress. It is set to .TRUE. automatically if calculation == 'vc-md' or 'vc-relax'"
        },
        "tprnfor": {
          "name": "tprnfor",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": null,
          "description": "calculate forces. It is set to .TRUE. automatically if calculation == 'relax','md','vc-md'",
          "options": [
            "'relax'",
            "'md'",
            "'vc-md'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "calculation == 'relax'"
            ]
          },
          "rawText": "calculate forces. It is set to .TRUE. automatically if calculation == 'relax','md','vc-md'"
        },
        "dt": {
          "name": "dt",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Real",
          "default": "20.D0",
          "description": "time step for molecular dynamics, in Rydberg atomic units (1 a.u.=4.8378 * 10^-17 s : beware, the CP code uses Hartree atomic units, half that much!!!)",
          "options": [],
          "units": "Ry",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "time step for molecular dynamics, in Rydberg atomic units (1 a.u.=4.8378 * 10^-17 s : beware, the CP code uses Hartree atomic units, half that much!!!)"
        },
        "outdir": {
          "name": "outdir",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "String",
          "default": "value of the ESPRESSO_TMPDIR environment variable if set; current directory ('./') otherwise",
          "description": "input, temporary, output files are found in this directory, see also wfcdir",
          "options": [],
          "units": "this",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "input, temporary, output files are found in this directory, see also wfcdir"
        },
        "wfcdir": {
          "name": "wfcdir",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "String",
          "default": "same as outdir",
          "description": "This directory specifies where to store files generated by each processor (*.wfc{N}, *.igk{N}, etc.). Useful for machines without a parallel file system: set wfcdir to a local file system, while outdir should be a parallel or network file system, visible to all processors. Beware: in order to restart from interrupted runs, or to perform further calculations using the produced data files, you may need to copy files to outdir . Works only for pw.x.",
          "options": [],
          "units": "order",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "This directory specifies where to store files generated by each processor (*.wfc{N}, *.igk{N}, etc.). Useful for machines without a parallel file system: set wfcdir to a local file system, while outdir should be a parallel or network file system, visible to all processors. Beware: in order to restart from interrupted runs, or to perform further calculations using the produced data files, you may need to copy files to outdir . Works only for pw.x."
        },
        "prefix": {
          "name": "prefix",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "String",
          "default": "'pwscf'",
          "description": "prepended to input/output filenames: prefix.wfc, prefix.rho, etc.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "prepended to input/output filenames: prefix.wfc, prefix.rho, etc."
        },
        "lkpoint_dir": {
          "name": "lkpoint_dir",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": null,
          "description": "OBSOLETE - NO LONGER IMPLEMENTED",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "OBSOLETE - NO LONGER IMPLEMENTED"
        },
        "max_seconds": {
          "name": "max_seconds",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D+7, or 150 days, i.e. no time limit",
          "description": "Jobs stops after max_seconds CPU time. Use this option in conjunction with option restart_mode if you need to split a job too long to complete into shorter jobs that fit into your batch queues.",
          "options": [],
          "units": "conjunction",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Jobs stops after max_seconds CPU time. Use this option in conjunction with option restart_mode if you need to split a job too long to complete into shorter jobs that fit into your batch queues."
        },
        "etot_conv_thr": {
          "name": "etot_conv_thr",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.0D-4",
          "description": "Convergence threshold on total energy (a.u) for ionic minimization: the convergence criterion is satisfied when the total energy changes less than etot_conv_thr between two consecutive scf steps. Note that etot_conv_thr is extensive, like the total energy. See also forc_conv_thr - both criteria must be satisfied",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Convergence threshold on total energy (a.u) for ionic minimization: the convergence criterion is satisfied when the total energy changes less than etot_conv_thr between two consecutive scf steps. Note that etot_conv_thr is extensive, like the total energy. See also forc_conv_thr - both criteria must be satisfied"
        },
        "forc_conv_thr": {
          "name": "forc_conv_thr",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.0D-3",
          "description": "Convergence threshold on forces (a.u) for ionic minimization: the convergence criterion is satisfied when all components of all forces are smaller than forc_conv_thr . See also etot_conv_thr - both criteria must be satisfied",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Convergence threshold on forces (a.u) for ionic minimization: the convergence criterion is satisfied when all components of all forces are smaller than forc_conv_thr . See also etot_conv_thr - both criteria must be satisfied"
        },
        "disk_io": {
          "name": "disk_io",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "String",
          "default": "see below",
          "description": "Specifies the amount of disk I/O activity: (only for binary files and xml data file in data directory; other files printed at each molecular dynamics / structural optimization step are not controlled by this option ) save charge to disk at each SCF step, keep wavefunctions on disk (in \"distributed\" format), save mixing data as well. Do not use this option unless you have a good reason! It is no longer needed to specify 'high' in order to be able to restart from an interrupted calculation (see restart_mode ) save charge to disk at each SCF step, keep wavefunctions on disk only if more than one k-point, per process is present, otherwise keep them in memory; save them to disk only at the end (in \"portable\" format) save charge to disk at each SCF step, keep wavefunctions in memory (for all k-points), save them to disk only at the end (in \"portable\" format). Reduces I/O but increases memory wrt the previous cases save to disk only the xml data file and the charge density at convergence, never save wavefunctions. Restarting from an interrupted calculation is not possible with this option. save to disk only the xml data file at convergence do not save anything to disk Default is 'low' for the scf case, 'medium' otherwise. Note that the needed RAM increases as disk I/O decreases",
          "options": [
            "'high'",
            "'medium'",
            "'low'",
            "'nowf'",
            "'minimal'",
            "'none'"
          ],
          "units": "data",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Specifies the amount of disk I/O activity: (only for binary files and xml data file in data directory; other files printed at each molecular dynamics / structural optimization step are not controlled by this option ) save charge to disk at each SCF step, keep wavefunctions on disk (in \"distributed\" format), save mixing data as well. Do not use this option unless you have a good reason! It is no longer needed to specify 'high' in order to be able to restart from an interrupted calculation (see restart_mode ) save charge to disk at each SCF step, keep wavefunctions on disk only if more than one k-point, per process is present, otherwise keep them in memory; save them to disk only at the end (in \"portable\" format) save charge to disk at each SCF step, keep wavefunctions in memory (for all k-points), save them to disk only at the end (in \"portable\" format). Reduces I/O but increases memory wrt the previous cases save to disk only the xml data file and the charge density at convergence, never save wavefunctions. Restarting from an interrupted calculation is not possible with this option. save to disk only the xml data file at convergence do not save anything to disk Default is 'low' for the scf case, 'medium' otherwise. Note that the needed RAM increases as disk I/O decreases"
        },
        "pseudo_dir": {
          "name": "pseudo_dir",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "String",
          "default": "value of the $ESPRESSO_PSEUDO environment variable if set; '$HOME/espresso/pseudo/' otherwise",
          "description": "directory containing pseudopotential files",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "directory containing pseudopotential files"
        },
        "tefield": {
          "name": "tefield",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE. a saw-like potential simulating an electric field is added to the bare ionic potential. See variables edir , eamp , emaxpos , eopreg for the form and size of the added potential.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE. a saw-like potential simulating an electric field is added to the bare ionic potential. See variables edir , eamp , emaxpos , eopreg for the form and size of the added potential."
        },
        "dipfield": {
          "name": "dipfield",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE. and tefield ==.TRUE. a dipole correction is also added to the bare ionic potential - implements the recipe of L. Bengtsson, PRB 59, 12301 (1999) . See variables edir , emaxpos , eopreg for the form of the correction. Must be used ONLY in a slab geometry, for surface calculations, with the discontinuity FALLING IN THE EMPTY SPACE.",
          "options": [],
          "units": "1999",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE. and tefield ==.TRUE. a dipole correction is also added to the bare ionic potential - implements the recipe of L. Bengtsson, PRB 59, 12301 (1999) . See variables edir , emaxpos , eopreg for the form of the correction. Must be used ONLY in a slab geometry, for surface calculations, with the discontinuity FALLING IN THE EMPTY SPACE."
        },
        "lelfield": {
          "name": "lelfield",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE. a homogeneous finite electric field described through the modern theory of the polarization is applied. This is different from tefield == .true. !",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE. a homogeneous finite electric field described through the modern theory of the polarization is applied. This is different from tefield == .true. !"
        },
        "nberrycyc": {
          "name": "nberrycyc",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "1",
          "description": "In the case of a finite electric field ( lelfield == .TRUE. ) it defines the number of iterations for converging the wavefunctions in the electric field Hamiltonian, for each external iteration on the charge density",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "In the case of a finite electric field ( lelfield == .TRUE. ) it defines the number of iterations for converging the wavefunctions in the electric field Hamiltonian, for each external iteration on the charge density"
        },
        "lorbm": {
          "name": "lorbm",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE. perform orbital magnetization calculation. If finite electric field is applied ( lelfield ==.true.) only Kubo terms are computed [for details see New J. Phys. 12, 053032 (2010), doi:10.1088/1367-2630/12/5/053032 ]. The type of calculation is 'nscf' and should be performed on an automatically generated uniform grid of k points. Works ONLY with norm-conserving pseudopotentials.",
          "options": [
            "'nscf'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE. perform orbital magnetization calculation. If finite electric field is applied ( lelfield ==.true.) only Kubo terms are computed [for details see New J. Phys. 12, 053032 (2010), doi:10.1088/1367-2630/12/5/053032 ]. The type of calculation is 'nscf' and should be performed on an automatically generated uniform grid of k points. Works ONLY with norm-conserving pseudopotentials."
        },
        "lberry": {
          "name": "lberry",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE. perform a Berry phase calculation. See the header of PW/src/bp_c_phase.f90 for documentation.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE. perform a Berry phase calculation. See the header of PW/src/bp_c_phase.f90 for documentation."
        },
        "gdir": {
          "name": "gdir",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Integer",
          "default": null,
          "description": "For Berry phase calculation: direction of the k-point strings in reciprocal space. Allowed values: 1, 2, 3 1=first, 2=second, 3=third reciprocal lattice vector For calculations with finite electric fields ( lelfield ==.true.) \"gdir\" is the direction of the field.",
          "options": [],
          "units": "reciprocal",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "For Berry phase calculation: direction of the k-point strings in reciprocal space. Allowed values: 1, 2, 3 1=first, 2=second, 3=third reciprocal lattice vector For calculations with finite electric fields ( lelfield ==.true.) \"gdir\" is the direction of the field."
        },
        "nppstr": {
          "name": "nppstr",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Integer",
          "default": null,
          "description": "For Berry phase calculation: number of k-points to be calculated along each symmetry-reduced string. The same for calculation with finite electric fields ( lelfield ==.true.).",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "For Berry phase calculation: number of k-points to be calculated along each symmetry-reduced string. The same for calculation with finite electric fields ( lelfield ==.true.)."
        },
        "gate": {
          "name": "gate",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "In the case of charged cells ( tot_charge .ne. 0) setting gate = .TRUE. represents the counter charge (i.e. -tot_charge) not by a homogeneous background charge but with a charged plate, which is placed at zgate (see below). Details of the gate potential can be found in T. Brumme, M. Calandra, F. Mauri; PRB 89, 245406 (2014) . Note, that in systems which are not symmetric with respect to the plate, one needs to enable the dipole correction! ( dipfield =.true.). Currently, symmetry can be used with gate=.true. but carefully check that no symmetry is included which maps z to - z even if in principle one could still use them for symmetric systems (i.e. no dipole correction). For nosym =.false. verbosity is set to 'high'. Note: this option was called \"monopole\" in v6.0 and 6.1 of pw.x",
          "options": [
            "'high'"
          ],
          "units": "T",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "In the case of charged cells ( tot_charge .ne. 0) setting gate = .TRUE. represents the counter charge (i.e. -tot_charge) not by a homogeneous background charge but with a charged plate, which is placed at zgate (see below). Details of the gate potential can be found in T. Brumme, M. Calandra, F. Mauri; PRB 89, 245406 (2014) . Note, that in systems which are not symmetric with respect to the plate, one needs to enable the dipole correction! ( dipfield =.true.). Currently, symmetry can be used with gate=.true. but carefully check that no symmetry is included which maps z to - z even if in principle one could still use them for symmetric systems (i.e. no dipole correction). For nosym =.false. verbosity is set to 'high'. Note: this option was called \"monopole\" in v6.0 and 6.1 of pw.x"
        },
        "twochem": {
          "name": "twochem",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "IF .TRUE. , a two chemical potential calculation for the simulation of photoexcited systems is performed, constraining a fraction of the electrons in the conduction manifold. See G. Marini, M. Calandra; PRB 104, 144103 (2021) . Note: requires occupations to be set to 'smearing'.",
          "options": [
            "'smearing'"
          ],
          "units": "2021",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "IF .TRUE. , a two chemical potential calculation for the simulation of photoexcited systems is performed, constraining a fraction of the electrons in the conduction manifold. See G. Marini, M. Calandra; PRB 104, 144103 (2021) . Note: requires occupations to be set to 'smearing'."
        },
        "lfcp": {
          "name": "lfcp",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE. perform a constant bias potential (constant-mu) calculation for a system with ESM method. See the header of PW/src/fcp_module.f90 for documentation. To perform the calculation, you must set a namelist FCP. NB: - The total energy displayed in output includes the potentiostat contribution (-mu*N). - calculation must be 'relax' or 'md'. - assume_isolated = 'esm' and esm_bc = 'bc2' or 'bc3' must be set in SYSTEM namelist. - ESM-RISM is also supported ( assume_isolated = 'esm' and esm_bc = 'bc1' and trism = .TRUE.). - ignore_wolfe is always .TRUE., for BFGS.",
          "options": [
            "'relax'",
            "'md'",
            "'esm'",
            "'bc2'",
            "'bc3'",
            "'bc1'"
          ],
          "units": "constant-mu",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE. perform a constant bias potential (constant-mu) calculation for a system with ESM method. See the header of PW/src/fcp_module.f90 for documentation. To perform the calculation, you must set a namelist FCP. NB: - The total energy displayed in output includes the potentiostat contribution (-mu*N). - calculation must be 'relax' or 'md'. - assume_isolated = 'esm' and esm_bc = 'bc2' or 'bc3' must be set in SYSTEM namelist. - ESM-RISM is also supported ( assume_isolated = 'esm' and esm_bc = 'bc1' and trism = .TRUE.). - ignore_wolfe is always .TRUE., for BFGS."
        },
        "trism": {
          "name": "trism",
          "section": "& CONTROL",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE. perform a 3D-RISM-SCF calculation [for details see H.Sato et al., JCP 112, 9463 (2000), doi:10.1063/1.481564 ]. The solvent's distributions are calculated by 3D-RISM, though solute is treated as SCF. The charge density and the atomic positions are optimized, simultaneously with the solvents. To perform the calculation, you must set a namelist RISM and a card SOLVENTS . If assume_isolated = 'esm' and esm_bc = 'bc1', Laue-RISM is calculated instead of 3D-RISM and coupled with ESM method (i.e. ESM-RISM). [for details see S.Nishihara and M.Otani, PRB 96, 115429 (2017) ]. The default of mixing_beta is 0.2 for both 3D-RISM and Laue-RISM. For structural relaxation with BFGS, ignore_wolfe is always .TRUE. .",
          "options": [
            "'s distributions are calculated by 3D-RISM, though solute is treated as SCF. The charge density and the atomic positions are optimized, simultaneously with the solvents. To perform the calculation, you must set a namelist RISM and a card SOLVENTS . If assume_isolated = '",
            "' and esm_bc = '"
          ],
          "units": "2000",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "assume_isolated = 'esm'"
            ]
          },
          "rawText": "If .TRUE. perform a 3D-RISM-SCF calculation [for details see H.Sato et al., JCP 112, 9463 (2000), doi:10.1063/1.481564 ]. The solvent's distributions are calculated by 3D-RISM, though solute is treated as SCF. The charge density and the atomic positions are optimized, simultaneously with the solvents. To perform the calculation, you must set a namelist RISM and a card SOLVENTS . If assume_isolated = 'esm' and esm_bc = 'bc1', Laue-RISM is calculated instead of 3D-RISM and coupled with ESM method (i.e. ESM-RISM). [for details see S.Nishihara and M.Otani, PRB 96, 115429 (2017) ]. The default of mixing_beta is 0.2 for both 3D-RISM and Laue-RISM. For structural relaxation with BFGS, ignore_wolfe is always .TRUE. ."
        }
      }
    },
    "& SYSTEM": {
      "sectionType": "namelist",
      "variables": {
        "ibrav": {
          "name": "ibrav",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": null,
          "description": "Bravais-lattice index. Optional only if space_group is set. If ibrav /= 0, specify EITHER [ celldm (1)- celldm (6) ] OR [ A , B , C , cosAB , cosAC , cosBC ] but NOT both. The lattice parameter \"alat\" is set to alat = celldm(1) (in a.u.) or alat = A (in Angstrom); see below for the other parameters. For ibrav=0 specify the lattice vectors in CELL_PARAMETERS , optionally the lattice parameter alat = celldm(1) (in a.u.) or = A (in Angstrom). If not specified, the lattice parameter is taken from CELL_PARAMETERS IMPORTANT NOTICE 1: with ibrav=0 lattice vectors must be given with a sufficiently large number of digits and with the correct symmetry, or else symmetry detection may fail and strange problems may arise in symmetrization. IMPORTANT NOTICE 2: do not use celldm(1) or A as a.u. to Ang conversion factor, use the true lattice parameters or nothing, specify units in CELL_PARAMETERS and ATOMIC_POSITIONS ibrav structure celldm(2)-celldm(6) or: b,c,cosbc,cosac,cosab 0 free crystal axis provided in input: see card CELL_PARAMETERS 1 cubic P (sc) v1 = a(1,0,0), v2 = a(0,1,0), v3 = a(0,0,1) 2 cubic F (fcc) v1 = (a/2)(-1,0,1), v2 = (a/2)(0,1,1), v3 = (a/2)(-1,1,0) 3 cubic I (bcc) v1 = (a/2)(1,1,1), v2 = (a/2)(-1,1,1), v3 = (a/2)(-1,-1,1) -3 cubic I (bcc), more symmetric axis: v1 = (a/2)(-1,1,1), v2 = (a/2)(1,-1,1), v3 = (a/2)(1,1,-1) 4 Hexagonal and Trigonal P celldm(3)=c/a v1 = a(1,0,0), v2 = a(-1/2,sqrt(3)/2,0), v3 = a(0,0,c/a) 5 Trigonal R, 3fold axis c celldm(4)=cos(gamma) The crystallographic vectors form a three-fold star around the z-axis, the primitive cell is a simple rhombohedron: v1 = a(tx,-ty,tz), v2 = a(0,2ty,tz), v3 = a(-tx,-ty,tz) where c=cos(gamma) is the cosine of the angle gamma between any pair of crystallographic vectors, tx, ty, tz are: tx=sqrt((1-c)/2), ty=sqrt((1-c)/6), tz=sqrt((1+2c)/3) -5 Trigonal R, 3fold axis <111> celldm(4)=cos(gamma) The crystallographic vectors form a three-fold star around <111>. Defining a' = a/sqrt(3) : v1 = a' (u,v,v), v2 = a' (v,u,v), v3 = a' (v,v,u) where u and v are defined as u = tz - 2*sqrt(2)*ty, v = tz + sqrt(2)*ty and tx, ty, tz as for case ibrav=5 Note: if you prefer x,y,z as axis in the cubic limit, set u = tz + 2*sqrt(2)*ty, v = tz - sqrt(2)*ty See also the note in Modules/latgen.f90 6 Tetragonal P (st) celldm(3)=c/a v1 = a(1,0,0), v2 = a(0,1,0), v3 = a(0,0,c/a) 7 Tetragonal I (bct) celldm(3)=c/a v1=(a/2)(1,-1,c/a), v2=(a/2)(1,1,c/a), v3=(a/2)(-1,-1,c/a) 8 Orthorhombic P celldm(2)=b/a celldm(3)=c/a v1 = (a,0,0), v2 = (0,b,0), v3 = (0,0,c) 9 Orthorhombic base-centered(bco) celldm(2)=b/a celldm(3)=c/a v1 = (a/2, b/2,0), v2 = (-a/2,b/2,0), v3 = (0,0,c) -9 as 9, alternate description v1 = (a/2,-b/2,0), v2 = (a/2, b/2,0), v3 = (0,0,c) 91 Orthorhombic one-face base-centered A-type celldm(2)=b/a celldm(3)=c/a v1 = (a, 0, 0), v2 = (0,b/2,-c/2), v3 = (0,b/2,c/2) 10 Orthorhombic face-centered celldm(2)=b/a celldm(3)=c/a v1 = (a/2,0,c/2), v2 = (a/2,b/2,0), v3 = (0,b/2,c/2) 11 Orthorhombic body-centered celldm(2)=b/a celldm(3)=c/a v1=(a/2,b/2,c/2), v2=(-a/2,b/2,c/2), v3=(-a/2,-b/2,c/2) 12 Monoclinic P, unique axis c celldm(2)=b/a celldm(3)=c/a, celldm(4)=cos(ab) v1=(a,0,0), v2=(b*cos(gamma),b*sin(gamma),0), v3 = (0,0,c) where gamma is the angle between axis a and b. -12 Monoclinic P, unique axis b celldm(2)=b/a celldm(3)=c/a, celldm(5)=cos(ac) v1 = (a,0,0), v2 = (0,b,0), v3 = (c*cos(beta),0,c*sin(beta)) where beta is the angle between axis a and c 13 Monoclinic base-centered celldm(2)=b/a (unique axis c) celldm(3)=c/a, celldm(4)=cos(gamma) v1 = ( a/2, 0, -c/2), v2 = (b*cos(gamma), b*sin(gamma), 0 ), v3 = ( a/2, 0, c/2), where gamma=angle between axis a and b projected on xy plane -13 Monoclinic base-centered celldm(2)=b/a (unique axis b) celldm(3)=c/a, celldm(5)=cos(beta) v1 = ( a/2, b/2, 0), v2 = ( -a/2, b/2, 0), v3 = (c*cos(beta), 0, c*sin(beta)), where beta=angle between axis a and c projected on xz plane IMPORTANT NOTICE: until QE v.6.4.1, axis for ibrav=-13 had a different definition: v1(old) =-v2(now), v2(old) = v1(now) 14 Triclinic celldm(2)= b/a, celldm(3)= c/a, celldm(4)= cos(bc), celldm(5)= cos(ac), celldm(6)= cos(ab) v1 = (a, 0, 0), v2 = (b*cos(gamma), b*sin(gamma), 0) v3 = (c*cos(beta), c*(cos(alpha)-cos(beta)cos(gamma))/sin(gamma), c*sqrt( 1 + 2*cos(alpha)cos(beta)cos(gamma) - cos(alpha)^2-cos(beta)^2-cos(gamma)^2 )/sin(gamma) ) where alpha is the angle between axis b and c beta is the angle between axis a and c gamma is the angle between axis a and b",
          "options": [
            "' = a/sqrt(3) : v1 = a'",
            "' (v,u,v), v3 = a'"
          ],
          "units": "1",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "is == .TRUE.",
              "ibrav /= 0",
              "ibrav = 0"
            ]
          },
          "rawText": "Bravais-lattice index. Optional only if space_group is set. If ibrav /= 0, specify EITHER [ celldm (1)- celldm (6) ] OR [ A , B , C , cosAB , cosAC , cosBC ] but NOT both. The lattice parameter \"alat\" is set to alat = celldm(1) (in a.u.) or alat = A (in Angstrom); see below for the other parameters. For ibrav=0 specify the lattice vectors in CELL_PARAMETERS , optionally the lattice parameter alat = celldm(1) (in a.u.) or = A (in Angstrom). If not specified, the lattice parameter is taken from CELL_PARAMETERS IMPORTANT NOTICE 1: with ibrav=0 lattice vectors must be given with a sufficiently large number of digits and with the correct symmetry, or else symmetry detection may fail and strange problems may arise in symmetrization. IMPORTANT NOTICE 2: do not use celldm(1) or A as a.u. to Ang conversion factor, use the true lattice parameters or nothing, specify units in CELL_PARAMETERS and ATOMIC_POSITIONS ibrav structure celldm(2)-celldm(6) or: b,c,cosbc,cosac,cosab 0 free crystal axis provided in input: see card CELL_PARAMETERS 1 cubic P (sc) v1 = a(1,0,0), v2 = a(0,1,0), v3 = a(0,0,1) 2 cubic F (fcc) v1 = (a/2)(-1,0,1), v2 = (a/2)(0,1,1), v3 = (a/2)(-1,1,0) 3 cubic I (bcc) v1 = (a/2)(1,1,1), v2 = (a/2)(-1,1,1), v3 = (a/2)(-1,-1,1) -3 cubic I (bcc), more symmetric axis: v1 = (a/2)(-1,1,1), v2 = (a/2)(1,-1,1), v3 = (a/2)(1,1,-1) 4 Hexagonal and Trigonal P celldm(3)=c/a v1 = a(1,0,0), v2 = a(-1/2,sqrt(3)/2,0), v3 = a(0,0,c/a) 5 Trigonal R, 3fold axis c celldm(4)=cos(gamma) The crystallographic vectors form a three-fold star around the z-axis, the primitive cell is a simple rhombohedron: v1 = a(tx,-ty,tz), v2 = a(0,2ty,tz), v3 = a(-tx,-ty,tz) where c=cos(gamma) is the cosine of the angle gamma between any pair of crystallographic vectors, tx, ty, tz are: tx=sqrt((1-c)/2), ty=sqrt((1-c)/6), tz=sqrt((1+2c)/3) -5 Trigonal R, 3fold axis <111> celldm(4)=cos(gamma) The crystallographic vectors form a three-fold star around <111>. Defining a' = a/sqrt(3) : v1 = a' (u,v,v), v2 = a' (v,u,v), v3 = a' (v,v,u) where u and v are defined as u = tz - 2*sqrt(2)*ty, v = tz + sqrt(2)*ty and tx, ty, tz as for case ibrav=5 Note: if you prefer x,y,z as axis in the cubic limit, set u = tz + 2*sqrt(2)*ty, v = tz - sqrt(2)*ty See also the note in Modules/latgen.f90 6 Tetragonal P (st) celldm(3)=c/a v1 = a(1,0,0), v2 = a(0,1,0), v3 = a(0,0,c/a) 7 Tetragonal I (bct) celldm(3)=c/a v1=(a/2)(1,-1,c/a), v2=(a/2)(1,1,c/a), v3=(a/2)(-1,-1,c/a) 8 Orthorhombic P celldm(2)=b/a celldm(3)=c/a v1 = (a,0,0), v2 = (0,b,0), v3 = (0,0,c) 9 Orthorhombic base-centered(bco) celldm(2)=b/a celldm(3)=c/a v1 = (a/2, b/2,0), v2 = (-a/2,b/2,0), v3 = (0,0,c) -9 as 9, alternate description v1 = (a/2,-b/2,0), v2 = (a/2, b/2,0), v3 = (0,0,c) 91 Orthorhombic one-face base-centered A-type celldm(2)=b/a celldm(3)=c/a v1 = (a, 0, 0), v2 = (0,b/2,-c/2), v3 = (0,b/2,c/2) 10 Orthorhombic face-centered celldm(2)=b/a celldm(3)=c/a v1 = (a/2,0,c/2), v2 = (a/2,b/2,0), v3 = (0,b/2,c/2) 11 Orthorhombic body-centered celldm(2)=b/a celldm(3)=c/a v1=(a/2,b/2,c/2), v2=(-a/2,b/2,c/2), v3=(-a/2,-b/2,c/2) 12 Monoclinic P, unique axis c celldm(2)=b/a celldm(3)=c/a, celldm(4)=cos(ab) v1=(a,0,0), v2=(b*cos(gamma),b*sin(gamma),0), v3 = (0,0,c) where gamma is the angle between axis a and b. -12 Monoclinic P, unique axis b celldm(2)=b/a celldm(3)=c/a, celldm(5)=cos(ac) v1 = (a,0,0), v2 = (0,b,0), v3 = (c*cos(beta),0,c*sin(beta)) where beta is the angle between axis a and c 13 Monoclinic base-centered celldm(2)=b/a (unique axis c) celldm(3)=c/a, celldm(4)=cos(gamma) v1 = ( a/2, 0, -c/2), v2 = (b*cos(gamma), b*sin(gamma), 0 ), v3 = ( a/2, 0, c/2), where gamma=angle between axis a and b projected on xy plane -13 Monoclinic base-centered celldm(2)=b/a (unique axis b) celldm(3)=c/a, celldm(5)=cos(beta) v1 = ( a/2, b/2, 0), v2 = ( -a/2, b/2, 0), v3 = (c*cos(beta), 0, c*sin(beta)), where beta=angle between axis a and c projected on xz plane IMPORTANT NOTICE: until QE v.6.4.1, axis for ibrav=-13 had a different definition: v1(old) =-v2(now), v2(old) = v1(now) 14 Triclinic celldm(2)= b/a, celldm(3)= c/a, celldm(4)= cos(bc), celldm(5)= cos(ac), celldm(6)= cos(ab) v1 = (a, 0, 0), v2 = (b*cos(gamma), b*sin(gamma), 0) v3 = (c*cos(beta), c*(cos(alpha)-cos(beta)cos(gamma))/sin(gamma), c*sqrt( 1 + 2*cos(alpha)cos(beta)cos(gamma) - cos(alpha)^2-cos(beta)^2-cos(gamma)^2 )/sin(gamma) ) where alpha is the angle between axis b and c beta is the angle between axis a and c gamma is the angle between axis a and b"
        },
        "celldm(i), i=1,6": {
          "name": "celldm(i), i=1,6",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Array",
          "default": null,
          "description": "Crystallographic constants - see the ibrav variable. Specify either these OR A , B , C , cosAB , cosBC , cosAC NOT both. Only needed values (depending on \"ibrav\") must be specified alat = celldm (1) is the lattice parameter \"a\" (in BOHR) If ibrav ==0, only celldm (1) is used if present; cell vectors are read from card CELL_PARAMETERS",
          "options": [],
          "units": "bohr",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "ibrav == 0"
            ]
          },
          "rawText": "Crystallographic constants - see the ibrav variable. Specify either these OR A , B , C , cosAB , cosBC , cosAC NOT both. Only needed values (depending on \"ibrav\") must be specified alat = celldm (1) is the lattice parameter \"a\" (in BOHR) If ibrav ==0, only celldm (1) is used if present; cell vectors are read from card CELL_PARAMETERS"
        },
        "A, B, C, cosAB, cosAC, cosBC": {
          "name": "A, B, C, cosAB, cosAC, cosBC",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": null,
          "description": "Traditional crystallographic constants: a,b,c in ANGSTROM cosAB = cosine of the angle between axis a and b (gamma) cosAC = cosine of the angle between axis a and c (beta) cosBC = cosine of the angle between axis b and c (alpha) The axis are chosen according to the value of ibrav . Specify either these OR celldm but NOT both. Only needed values (depending on ibrav ) must be specified. The lattice parameter alat = A (in ANGSTROM ). If ibrav == 0, only A is used if present, and cell vectors are read from card CELL_PARAMETERS .",
          "options": [],
          "units": "gamma",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "ibrav == 0"
            ]
          },
          "rawText": "Traditional crystallographic constants: a,b,c in ANGSTROM cosAB = cosine of the angle between axis a and b (gamma) cosAC = cosine of the angle between axis a and c (beta) cosBC = cosine of the angle between axis b and c (alpha) The axis are chosen according to the value of ibrav . Specify either these OR celldm but NOT both. Only needed values (depending on ibrav ) must be specified. The lattice parameter alat = A (in ANGSTROM ). If ibrav == 0, only A is used if present, and cell vectors are read from card CELL_PARAMETERS ."
        },
        "nat": {
          "name": "nat",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": null,
          "description": "number of atoms in the unit cell (ALL atoms, except if space_group is set, in which case, INEQUIVALENT atoms)",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "is == .TRUE."
            ]
          },
          "rawText": "number of atoms in the unit cell (ALL atoms, except if space_group is set, in which case, INEQUIVALENT atoms)"
        },
        "ntyp": {
          "name": "ntyp",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": null,
          "description": "number of types of atoms in the unit cell",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "number of types of atoms in the unit cell"
        },
        "nbnd": {
          "name": "nbnd",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "for an insulator, nbnd = number of valence bands ( nbnd = # of electrons /2); for a metal, 20% more (minimum 4 more)",
          "description": "Number of electronic states (bands) to be calculated. Note that in spin-polarized calculations the number of k-point, not the number of bands per k-point, is doubled",
          "options": [],
          "units": "bands",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Number of electronic states (bands) to be calculated. Note that in spin-polarized calculations the number of k-point, not the number of bands per k-point, is doubled"
        },
        "nbnd_cond": {
          "name": "nbnd_cond",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "nbnd_cond = nbnd - # of electrons / 2 in the collinear case; nbnd_cond = nbnd - # of electrons in the noncollinear case.",
          "description": "Number of electronic states in the conduction manifold for a two chemical-potential calculation ( twochem =.true.).",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Number of electronic states in the conduction manifold for a two chemical-potential calculation ( twochem =.true.)."
        },
        "tot_charge": {
          "name": "tot_charge",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.0",
          "description": "Total charge of the system. Useful for simulations with charged cells. By default the unit cell is assumed to be neutral (tot_charge=0). tot_charge=+1 means one electron missing from the system, tot_charge=-1 means one additional electron, and so on. In a periodic calculation a compensating jellium background is inserted to remove divergences if the cell is not neutral.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Total charge of the system. Useful for simulations with charged cells. By default the unit cell is assumed to be neutral (tot_charge=0). tot_charge=+1 means one electron missing from the system, tot_charge=-1 means one additional electron, and so on. In a periodic calculation a compensating jellium background is inserted to remove divergences if the cell is not neutral."
        },
        "starting_charge(i), i=1,ntyp": {
          "name": "starting_charge(i), i=1,ntyp",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Array",
          "default": "0.0",
          "description": "starting charge on atomic type 'i', to create starting potential with startingpot = 'atomic'.",
          "options": [
            "'i'",
            "'atomic'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "starting charge on atomic type 'i', to create starting potential with startingpot = 'atomic'."
        },
        "tot_magnetization": {
          "name": "tot_magnetization",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "-10000 [unspecified]",
          "description": "Total majority spin charge - minority spin charge. Used to impose a specific total electronic magnetization. If unspecified then tot_magnetization variable is ignored and the amount of electronic magnetization is determined during the self-consistent cycle.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Total majority spin charge - minority spin charge. Used to impose a specific total electronic magnetization. If unspecified then tot_magnetization variable is ignored and the amount of electronic magnetization is determined during the self-consistent cycle."
        },
        "starting_magnetization(i), i=1,ntyp": {
          "name": "starting_magnetization(i), i=1,ntyp",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Array",
          "default": "0",
          "description": "Starting spin polarization on atomic type 'i' in a spin-polarized (LSDA or non-collinear/spin-orbit) calculation. The input values can have an absolute value greater than or equal to 1, which will be interpreted as the site's magnetic moment. Alternatively, the values can range between -1 and 1, which will be interpreted as the site magnetization per valence electron. For QE-v7.2 and older versions, only the second option is allowed. If you expect a nonzero magnetization in your ground state, you MUST either specify a nonzero value for at least one atomic type, or constrain the magnetization using variable tot_magnetization for LSDA, constrained_magnetization for noncollinear/spin-orbit calculations. If you don't, you will get a nonmagnetic (zero magnetization) state. In order to perform LSDA calculations for an antiferromagnetic state, define two different atomic species corresponding to sublattices of the same atomic type. NOTE 1: starting_magnetization is ignored in most BUT NOT ALL cases in non-scf calculations: it is safe to keep the same values for the scf and subsequent non-scf calculation. NOTE 2: If you fix the magnetization with tot_magnetization , do not specify starting_magnetization . NOTE 3: In the noncollinear/spin-orbit case, starting with zero starting_magnetization on all atoms imposes time reversal symmetry. The magnetization is never calculated and is set to zero (the internal variable domag is set to .FALSE.).",
          "options": [
            "'i'",
            "'s magnetic moment. Alternatively, the values can range between -1 and 1, which will be interpreted as the site magnetization per valence electron. For QE-v7.2 and older versions, only the second option is allowed. If you expect a nonzero magnetization in your ground state, you MUST either specify a nonzero value for at least one atomic type, or constrain the magnetization using variable tot_magnetization for LSDA, constrained_magnetization for noncollinear/spin-orbit calculations. If you don'"
          ],
          "units": "a",
          "range": "-1..1",
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Starting spin polarization on atomic type 'i' in a spin-polarized (LSDA or non-collinear/spin-orbit) calculation. The input values can have an absolute value greater than or equal to 1, which will be interpreted as the site's magnetic moment. Alternatively, the values can range between -1 and 1, which will be interpreted as the site magnetization per valence electron. For QE-v7.2 and older versions, only the second option is allowed. If you expect a nonzero magnetization in your ground state, you MUST either specify a nonzero value for at least one atomic type, or constrain the magnetization using variable tot_magnetization for LSDA, constrained_magnetization for noncollinear/spin-orbit calculations. If you don't, you will get a nonmagnetic (zero magnetization) state. In order to perform LSDA calculations for an antiferromagnetic state, define two different atomic species corresponding to sublattices of the same atomic type. NOTE 1: starting_magnetization is ignored in most BUT NOT ALL cases in non-scf calculations: it is safe to keep the same values for the scf and subsequent non-scf calculation. NOTE 2: If you fix the magnetization with tot_magnetization , do not specify starting_magnetization . NOTE 3: In the noncollinear/spin-orbit case, starting with zero starting_magnetization on all atoms imposes time reversal symmetry. The magnetization is never calculated and is set to zero (the internal variable domag is set to .FALSE.)."
        },
        "ecutwfc": {
          "name": "ecutwfc",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": null,
          "description": "kinetic energy cutoff (Ry) for wavefunctions",
          "options": [],
          "units": "Ry",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "kinetic energy cutoff (Ry) for wavefunctions"
        },
        "ecutrho": {
          "name": "ecutrho",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "4 * ecutwfc",
          "description": "Kinetic energy cutoff (Ry) for charge density and potential For norm-conserving pseudopotential you should stick to the default value, you can reduce it by a little but it will introduce noise especially on forces and stress. If there are ultrasoft PP, a larger value than the default is often desirable (ecutrho = 8 to 12 times ecutwfc , typically). PAW datasets can often be used at 4* ecutwfc , but it depends on the shape of augmentation charge: testing is mandatory. The use of gradient-corrected functional, especially in cells with vacuum, or for pseudopotential without non-linear core correction, usually requires an higher values of ecutrho to be accurately converged.",
          "options": [],
          "units": "Ry",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "ecutrho = 8"
            ]
          },
          "rawText": "Kinetic energy cutoff (Ry) for charge density and potential For norm-conserving pseudopotential you should stick to the default value, you can reduce it by a little but it will introduce noise especially on forces and stress. If there are ultrasoft PP, a larger value than the default is often desirable (ecutrho = 8 to 12 times ecutwfc , typically). PAW datasets can often be used at 4* ecutwfc , but it depends on the shape of augmentation charge: testing is mandatory. The use of gradient-corrected functional, especially in cells with vacuum, or for pseudopotential without non-linear core correction, usually requires an higher values of ecutrho to be accurately converged."
        },
        "ecutfock": {
          "name": "ecutfock",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "ecutrho",
          "description": "Kinetic energy cutoff (Ry) for the exact exchange operator in EXX type calculations. By default this is the same as ecutrho but in some EXX calculations, a significant speed-up can be obtained by reducing ecutfock, at the expense of some loss in accuracy. Must be .gt. ecutwfc . Not implemented for stress calculation and for US-PP and PAW pseudopotentials. Use with care, especially in metals where it may give raise to instabilities.",
          "options": [],
          "units": "Ry",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Kinetic energy cutoff (Ry) for the exact exchange operator in EXX type calculations. By default this is the same as ecutrho but in some EXX calculations, a significant speed-up can be obtained by reducing ecutfock, at the expense of some loss in accuracy. Must be .gt. ecutwfc . Not implemented for stress calculation and for US-PP and PAW pseudopotentials. Use with care, especially in metals where it may give raise to instabilities."
        },
        "nr1, nr2, nr3": {
          "name": "nr1, nr2, nr3",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": null,
          "description": "Three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified the grid is calculated based on the cutoff for charge density (see also ecutrho ) Note: you must specify all three dimensions for this setting to be used.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified the grid is calculated based on the cutoff for charge density (see also ecutrho ) Note: you must specify all three dimensions for this setting to be used."
        },
        "nr1s, nr2s, nr3s": {
          "name": "nr1s, nr2s, nr3s",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": null,
          "description": "Three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Coincides with nr1 , nr2 , nr3 if ecutrho = 4 * ecutwfc ( default ) Note: you must specify all three dimensions for this setting to be used.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "ecutrho = 4"
            ]
          },
          "rawText": "Three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Coincides with nr1 , nr2 , nr3 if ecutrho = 4 * ecutwfc ( default ) Note: you must specify all three dimensions for this setting to be used."
        },
        "nosym": {
          "name": "nosym",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "if (.TRUE.) symmetry is not used. Consequences: - if a list of k points is provided in input, it is used \"as is\": symmetry-inequivalent k-points are not generated, and the charge density is not symmetrized; - if a uniform (Monkhorst-Pack) k-point grid is provided in input, it is expanded to cover the entire Brillouin Zone, irrespective of the crystal symmetry. Time reversal symmetry is assumed so k and -k are considered as equivalent unless noinv =.true. is specified. Do not use this option unless you know exactly what you want and what you get. May be useful in the following cases: - in low-symmetry large cells, if you cannot afford a k-point grid with the correct symmetry - in MD simulations - in calculations for isolated atoms",
          "options": [],
          "units": ".TRUE.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "if (.TRUE.) symmetry is not used. Consequences: - if a list of k points is provided in input, it is used \"as is\": symmetry-inequivalent k-points are not generated, and the charge density is not symmetrized; - if a uniform (Monkhorst-Pack) k-point grid is provided in input, it is expanded to cover the entire Brillouin Zone, irrespective of the crystal symmetry. Time reversal symmetry is assumed so k and -k are considered as equivalent unless noinv =.true. is specified. Do not use this option unless you know exactly what you want and what you get. May be useful in the following cases: - in low-symmetry large cells, if you cannot afford a k-point grid with the correct symmetry - in MD simulations - in calculations for isolated atoms"
        },
        "nosym_evc": {
          "name": "nosym_evc",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "if (.TRUE.) symmetry is not used, and k points are forced to have the symmetry of the Bravais lattice; an automatically generated Monkhorst-Pack grid will contain all points of the grid over the entire Brillouin Zone, plus the points rotated by the symmetries of the Bravais lattice which were not in the original grid. The same applies if a k-point list is provided in input instead of a Monkhorst-Pack grid. Time reversal symmetry is assumed so k and -k are equivalent unless noinv =.true. is specified. This option differs from nosym because it forces k-points in all cases to have the full symmetry of the Bravais lattice (not all uniform grids have such property!)",
          "options": [],
          "units": ".TRUE.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "if (.TRUE.) symmetry is not used, and k points are forced to have the symmetry of the Bravais lattice; an automatically generated Monkhorst-Pack grid will contain all points of the grid over the entire Brillouin Zone, plus the points rotated by the symmetries of the Bravais lattice which were not in the original grid. The same applies if a k-point list is provided in input instead of a Monkhorst-Pack grid. Time reversal symmetry is assumed so k and -k are equivalent unless noinv =.true. is specified. This option differs from nosym because it forces k-points in all cases to have the full symmetry of the Bravais lattice (not all uniform grids have such property!)"
        },
        "noinv": {
          "name": "noinv",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "if (.TRUE.) disable the usage of k => -k symmetry (time reversal) in k-point generation",
          "options": [],
          "units": ".TRUE.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "if (.TRUE.) disable the usage of k => -k symmetry (time reversal) in k-point generation"
        },
        "no_t_rev": {
          "name": "no_t_rev",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "if (.TRUE.) disable the usage of magnetic symmetry operations that consist in a rotation + time reversal.",
          "options": [],
          "units": ".TRUE.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "if (.TRUE.) disable the usage of magnetic symmetry operations that consist in a rotation + time reversal."
        },
        "force_symmorphic": {
          "name": "force_symmorphic",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "if (.TRUE.) force the symmetry group to be symmorphic by disabling symmetry operations having an associated fractionary translation",
          "options": [],
          "units": ".TRUE.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "if (.TRUE.) force the symmetry group to be symmorphic by disabling symmetry operations having an associated fractionary translation"
        },
        "use_all_frac": {
          "name": "use_all_frac",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "if (.FALSE.) force real-space FFT grids to be commensurate with fractionary translations of non-symmorphic symmetry operations, if present (e.g.: if a fractional translation (0,0,c/4) exists, the FFT dimension along the c axis must be multiple of 4). if (.TRUE.) do not impose any constraints to FFT grids, even in the presence of non-symmorphic symmetry operations. BEWARE: use_all_frac=.TRUE. may lead to wrong results for hybrid functionals and phonon calculations. Both cases use symmetrization in real space that works for non-symmorphic operations only if the real-space FFT grids are commensurate.",
          "options": [],
          "units": ".FALSE.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "if (.FALSE.) force real-space FFT grids to be commensurate with fractionary translations of non-symmorphic symmetry operations, if present (e.g.: if a fractional translation (0,0,c/4) exists, the FFT dimension along the c axis must be multiple of 4). if (.TRUE.) do not impose any constraints to FFT grids, even in the presence of non-symmorphic symmetry operations. BEWARE: use_all_frac=.TRUE. may lead to wrong results for hybrid functionals and phonon calculations. Both cases use symmetrization in real space that works for non-symmorphic operations only if the real-space FFT grids are commensurate."
        },
        "occupations": {
          "name": "occupations",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "String",
          "default": null,
          "description": "Available options are: gaussian smearing for metals; see variables smearing and degauss Tetrahedron method, Bloechl's version: P.E. Bloechl, PRB 49, 16223 (1994) Requires uniform grid of k-points, to be automatically generated (see card K_POINTS ). Well suited for calculation of DOS, less so (because not variational) for force/optimization/dynamics calculations. Original linear tetrahedron method. To be used only as a reference; the optimized tetrahedron method is more efficient. Optimized tetrahedron method: see M. Kawamura, PRB 89, 094515 (2014) . Can be used for phonon calculations as well. for insulators with a gap The occupation are read from input file, card OCCUPATIONS . Option valid only for a single k-point, requires nbnd to be set in input. Occupations should be consistent with the value of tot_charge .",
          "options": [
            "'smearing'",
            "'tetrahedra'",
            "'tetrahedra_lin'",
            "'tetrahedra_opt'",
            "'fixed'",
            "'from_input'"
          ],
          "units": "1994",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Available options are: gaussian smearing for metals; see variables smearing and degauss Tetrahedron method, Bloechl's version: P.E. Bloechl, PRB 49, 16223 (1994) Requires uniform grid of k-points, to be automatically generated (see card K_POINTS ). Well suited for calculation of DOS, less so (because not variational) for force/optimization/dynamics calculations. Original linear tetrahedron method. To be used only as a reference; the optimized tetrahedron method is more efficient. Optimized tetrahedron method: see M. Kawamura, PRB 89, 094515 (2014) . Can be used for phonon calculations as well. for insulators with a gap The occupation are read from input file, card OCCUPATIONS . Option valid only for a single k-point, requires nbnd to be set in input. Occupations should be consistent with the value of tot_charge ."
        },
        "one_atom_occupations": {
          "name": "one_atom_occupations",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "This flag is used for isolated atoms ( nat =1) together with occupations ='from_input'. If it is .TRUE., the wavefunctions are ordered as the atomic starting wavefunctions, independently from their eigenvalue. The occupations indicate which atomic states are filled. The order of the states is written inside the UPF pseudopotential file. In the scalar relativistic case: S -> l=0, m=0 P -> l=1, z, x, y D -> l=2, r^2-3z^2, xz, yz, xy, x^2-y^2 In the noncollinear magnetic case (with or without spin-orbit), each group of states is doubled. For instance: P -> l=1, z, x, y for spin up, l=1, z, x, y for spin down. Up and down is relative to the direction of the starting magnetization. In the case with spin-orbit and time-reversal ( starting_magnetization =0.0) the atomic wavefunctions are radial functions multiplied by spin-angle functions. For instance: P -> l=1, j=1/2, m_j=-1/2,1/2. l=1, j=3/2, m_j=-3/2, -1/2, 1/2, 3/2. In the magnetic case with spin-orbit the atomic wavefunctions can be forced to be spin-angle functions by setting starting_spin_angle to .TRUE..",
          "options": [
            "'from_input'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "This flag is used for isolated atoms ( nat =1) together with occupations ='from_input'. If it is .TRUE., the wavefunctions are ordered as the atomic starting wavefunctions, independently from their eigenvalue. The occupations indicate which atomic states are filled. The order of the states is written inside the UPF pseudopotential file. In the scalar relativistic case: S -> l=0, m=0 P -> l=1, z, x, y D -> l=2, r^2-3z^2, xz, yz, xy, x^2-y^2 In the noncollinear magnetic case (with or without spin-orbit), each group of states is doubled. For instance: P -> l=1, z, x, y for spin up, l=1, z, x, y for spin down. Up and down is relative to the direction of the starting magnetization. In the case with spin-orbit and time-reversal ( starting_magnetization =0.0) the atomic wavefunctions are radial functions multiplied by spin-angle functions. For instance: P -> l=1, j=1/2, m_j=-1/2,1/2. l=1, j=3/2, m_j=-3/2, -1/2, 1/2, 3/2. In the magnetic case with spin-orbit the atomic wavefunctions can be forced to be spin-angle functions by setting starting_spin_angle to .TRUE.."
        },
        "starting_spin_angle": {
          "name": "starting_spin_angle",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "In the spin-orbit case when domag =.TRUE., by default, the starting wavefunctions are initialized as in scalar relativistic noncollinear case without spin-orbit. By setting starting_spin_angle =.TRUE. this behaviour can be changed and the initial wavefunctions are radial functions multiplied by spin-angle functions. When domag =.FALSE. the initial wavefunctions are always radial functions multiplied by spin-angle functions independently from this flag. When lspinorb is .FALSE. this flag is not used.",
          "options": [],
          "units": "scalar",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "In the spin-orbit case when domag =.TRUE., by default, the starting wavefunctions are initialized as in scalar relativistic noncollinear case without spin-orbit. By setting starting_spin_angle =.TRUE. this behaviour can be changed and the initial wavefunctions are radial functions multiplied by spin-angle functions. When domag =.FALSE. the initial wavefunctions are always radial functions multiplied by spin-angle functions independently from this flag. When lspinorb is .FALSE. this flag is not used."
        },
        "degauss_cond": {
          "name": "degauss_cond",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.D0 Ry",
          "description": "value of the gaussian spreading (Ry) for brillouin-zone integration in the conduction manifold in a two-chemical potential calculation ( twochem =.true.).",
          "options": [],
          "units": "Ry",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "value of the gaussian spreading (Ry) for brillouin-zone integration in the conduction manifold in a two-chemical potential calculation ( twochem =.true.)."
        },
        "nelec_cond": {
          "name": "nelec_cond",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.D0",
          "description": "Number of electrons placed in the conduction manifold in a two-chemical potential calculation ( twochem =.true.). Of the total # of electrons nelec, nelec-nelec_cond will occupy the valence manifold and nelec_cond will be constrained in the conduction manifold.",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Number of electrons placed in the conduction manifold in a two-chemical potential calculation ( twochem =.true.). Of the total # of electrons nelec, nelec-nelec_cond will occupy the valence manifold and nelec_cond will be constrained in the conduction manifold."
        },
        "degauss": {
          "name": "degauss",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.D0 Ry",
          "description": "value of the gaussian spreading (Ry) for brillouin-zone integration in metals.",
          "options": [],
          "units": "Ry",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "value of the gaussian spreading (Ry) for brillouin-zone integration in metals."
        },
        "smearing": {
          "name": "smearing",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "String",
          "default": "'gaussian'",
          "description": "Available options are: ordinary Gaussian spreading (Default) Methfessel-Paxton first-order spreading (see PRB 40, 3616 (1989) ). Marzari-Vanderbilt-DeVita-Payne cold smearing (see PRL 82, 3296 (1999) ) smearing with Fermi-Dirac function",
          "options": [
            "'gaussian'",
            "'gauss'",
            "'methfessel-paxton'",
            "'m-p'",
            "'mp'",
            "'marzari-vanderbilt'",
            "'cold'",
            "'m-v'",
            "'mv'",
            "'fermi-dirac'",
            "'f-d'",
            "'fd'"
          ],
          "units": "Default",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Available options are: ordinary Gaussian spreading (Default) Methfessel-Paxton first-order spreading (see PRB 40, 3616 (1989) ). Marzari-Vanderbilt-DeVita-Payne cold smearing (see PRL 82, 3296 (1999) ) smearing with Fermi-Dirac function"
        },
        "nspin": {
          "name": "nspin",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "1",
          "description": "nspin = 1 : non-polarized calculation (default) nspin = 2 : spin-polarized calculation, LSDA (magnetization along z axis) nspin = 4 : spin-polarized calculation, noncollinear (magnetization in generic direction) DO NOT specify nspin in this case; specify noncolin =.TRUE. instead",
          "options": [],
          "units": "default",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "nspin = 1 : non-polarized calculation (default) nspin = 2 : spin-polarized calculation, LSDA (magnetization along z axis) nspin = 4 : spin-polarized calculation, noncollinear (magnetization in generic direction) DO NOT specify nspin in this case; specify noncolin =.TRUE. instead"
        },
        "sic_gamma": {
          "name": "sic_gamma",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0",
          "description": "Strength of the gammaDFT potential.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Strength of the gammaDFT potential."
        },
        "pol_type": {
          "name": "pol_type",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "String",
          "default": null,
          "description": "Type of polaron in gammaDFT. electron polaron hole polaron",
          "options": [
            "'e'",
            "'h'"
          ],
          "units": "gammaDFT",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Type of polaron in gammaDFT. electron polaron hole polaron"
        },
        "sic_energy": {
          "name": "sic_energy",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".false.",
          "description": "Enable the calculation of the total energy in gammaDFT. When .true., a preliminary calculation is performed to calculate the electron density in the absence of the polaron. When .false., the total energy printed in output should not be considered. For structural relaxations, it is recommended to use .false. to avoid doubling the computational cost.",
          "options": [],
          "units": "gammaDFT",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Enable the calculation of the total energy in gammaDFT. When .true., a preliminary calculation is performed to calculate the electron density in the absence of the polaron. When .false., the total energy printed in output should not be considered. For structural relaxations, it is recommended to use .false. to avoid doubling the computational cost."
        },
        "sci_vb": {
          "name": "sci_vb",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0",
          "description": "Valence band shift (in eV) through self-consistent scissor operator. When performing gammaDFT calculations of polarons, the polaron level is not shifted.",
          "options": [],
          "units": "eV",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Valence band shift (in eV) through self-consistent scissor operator. When performing gammaDFT calculations of polarons, the polaron level is not shifted."
        },
        "sci_cb": {
          "name": "sci_cb",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0",
          "description": "Conduction band band shift (in eV) through self-consistent scissor operator. When performing gammaDFT calculations of polarons, the polaron level is not shifted.",
          "options": [],
          "units": "eV",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Conduction band band shift (in eV) through self-consistent scissor operator. When performing gammaDFT calculations of polarons, the polaron level is not shifted."
        },
        "noncolin": {
          "name": "noncolin",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".false.",
          "description": "if .true. the program will perform a noncollinear calculation.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "if .true. the program will perform a noncollinear calculation."
        },
        "ecfixed": {
          "name": "ecfixed",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.0",
          "description": null,
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": null
        },
        "qcutz": {
          "name": "qcutz",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.0",
          "description": null,
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": null
        },
        "q2sigma": {
          "name": "q2sigma",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.1",
          "description": "ecfixed, qcutz, q2sigma: parameters for modified functional to be used in variable-cell molecular dynamics (or in stress calculation). \"ecfixed\" is the value (in Rydberg) of the constant-cutoff; \"qcutz\" and \"q2sigma\" are the height and the width (in Rydberg) of the energy step for reciprocal vectors whose square modulus is greater than \"ecfixed\". In the kinetic energy, G^2 is replaced by G^2 + qcutz * (1 + erf ( (G^2 - ecfixed)/q2sigma) ) See: M. Bernasconi et al, J. Phys. Chem. Solids 56, 501 (1995), doi:10.1016/0022-3697(94)00228-2",
          "options": [],
          "units": "stress",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "ecfixed, qcutz, q2sigma: parameters for modified functional to be used in variable-cell molecular dynamics (or in stress calculation). \"ecfixed\" is the value (in Rydberg) of the constant-cutoff; \"qcutz\" and \"q2sigma\" are the height and the width (in Rydberg) of the energy step for reciprocal vectors whose square modulus is greater than \"ecfixed\". In the kinetic energy, G^2 is replaced by G^2 + qcutz * (1 + erf ( (G^2 - ecfixed)/q2sigma) ) See: M. Bernasconi et al, J. Phys. Chem. Solids 56, 501 (1995), doi:10.1016/0022-3697(94)00228-2"
        },
        "input_dft": {
          "name": "input_dft",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "String",
          "default": "read from pseudopotential files",
          "description": "Exchange-correlation functional: eg 'PBE', 'BLYP' etc See Modules/funct.f90 for allowed values. Overrides the value read from pseudopotential files. Use with care and if you know what you are doing!",
          "options": [
            "'PBE'",
            "'BLYP'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Exchange-correlation functional: eg 'PBE', 'BLYP' etc See Modules/funct.f90 for allowed values. Overrides the value read from pseudopotential files. Use with care and if you know what you are doing!"
        },
        "ace": {
          "name": "ace",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": "true",
          "description": "Use Adaptively Compressed Exchange operator as in Lin Lin, J. Chem. Theory Comput. 2016, 12, 2242--2249, doi:10.1021/acs.jctc.6b00092 Set to false to use standard Exchange (much slower)",
          "options": [],
          "units": "Lin",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Use Adaptively Compressed Exchange operator as in Lin Lin, J. Chem. Theory Comput. 2016, 12, 2242--2249, doi:10.1021/acs.jctc.6b00092 Set to false to use standard Exchange (much slower)"
        },
        "exx_fraction": {
          "name": "exx_fraction",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "it depends on the specified functional",
          "description": "Fraction of EXX for hybrid functional calculations. In the case of input_dft ='PBE0', the default value is 0.25, while for input_dft ='B3LYP' the exx_fraction default value is 0.20.",
          "options": [
            "'PBE0'",
            "'B3LYP'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Fraction of EXX for hybrid functional calculations. In the case of input_dft ='PBE0', the default value is 0.25, while for input_dft ='B3LYP' the exx_fraction default value is 0.20."
        },
        "screening_parameter": {
          "name": "screening_parameter",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.106",
          "description": "screening_parameter for HSE like hybrid functionals. For more information, see: J. Chem. Phys. 118, 8207 (2003), doi:10.1063/1.1564060 J. Chem. Phys. 124, 219906 (2006), doi:10.1063/1.2204597",
          "options": [],
          "units": "2003",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "screening_parameter for HSE like hybrid functionals. For more information, see: J. Chem. Phys. 118, 8207 (2003), doi:10.1063/1.1564060 J. Chem. Phys. 124, 219906 (2006), doi:10.1063/1.2204597"
        },
        "exxdiv_treatment": {
          "name": "exxdiv_treatment",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "String",
          "default": "'gygi-baldereschi'",
          "description": "Specific for EXX. It selects the kind of approach to be used for treating the Coulomb potential divergencies at small q vectors. appropriate for cubic and quasi-cubic supercells appropriate for cubic and quasi-cubic supercells (untested for non-orthogonal crystal axis) appropriate for strongly anisotropic supercells, see also ecutvcut (untested for non-orthogonal crystal axis) sets Coulomb potential at G,q=0 to 0.0 (required for GAU-PBE)",
          "options": [
            "'gygi-baldereschi'",
            "'vcut_spherical'",
            "'vcut_ws'",
            "'none'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Specific for EXX. It selects the kind of approach to be used for treating the Coulomb potential divergencies at small q vectors. appropriate for cubic and quasi-cubic supercells appropriate for cubic and quasi-cubic supercells (untested for non-orthogonal crystal axis) appropriate for strongly anisotropic supercells, see also ecutvcut (untested for non-orthogonal crystal axis) sets Coulomb potential at G,q=0 to 0.0 (required for GAU-PBE)"
        },
        "x_gamma_extrapolation": {
          "name": "x_gamma_extrapolation",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".true.",
          "description": "Specific for EXX. If .true., extrapolate the G=0 term of the potential (see README in examples/EXX_example for more) Set this to .false. for GAU-PBE.",
          "options": [],
          "units": "examples/",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Specific for EXX. If .true., extrapolate the G=0 term of the potential (see README in examples/EXX_example for more) Set this to .false. for GAU-PBE."
        },
        "ecutvcut": {
          "name": "ecutvcut",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.0 Ry",
          "description": "Reciprocal space cutoff for correcting Coulomb potential divergencies at small q vectors.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Reciprocal space cutoff for correcting Coulomb potential divergencies at small q vectors."
        },
        "nqx1, nqx2, nqx3": {
          "name": "nqx1, nqx2, nqx3",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": null,
          "description": "Three-dimensional mesh for q (k1-k2) sampling of the Fock operator (EXX). Can be smaller than the number of k-points. Currently this defaults to the size of the k-point mesh used. In QE =< 5.0.2 it defaulted to nqx1=nqx2=nqx3=1.",
          "options": [],
          "units": "k1-k2",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Three-dimensional mesh for q (k1-k2) sampling of the Fock operator (EXX). Can be smaller than the number of k-points. Currently this defaults to the size of the k-point mesh used. In QE =< 5.0.2 it defaulted to nqx1=nqx2=nqx3=1."
        },
        "localization_thr": {
          "name": "localization_thr",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.0",
          "description": "Overlap threshold over which the exchange integral over a pair of localized orbitals is included in the evaluation of EXX operator. Any value greater than 0.0 triggers the SCDM localization and the evaluation on EXX using the localized orbitals. Very small value of the threshold should yield the same result as the default EXX evaluation",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Overlap threshold over which the exchange integral over a pair of localized orbitals is included in the evaluation of EXX operator. Any value greater than 0.0 triggers the SCDM localization and the evaluation on EXX using the localized orbitals. Very small value of the threshold should yield the same result as the default EXX evaluation"
        },
        "Hubbard_occ(ityp,i), (ityp,i) = (1,1) . . . (ntyp,3)": {
          "name": "Hubbard_occ(ityp,i), (ityp,i) = (1,1) . . . (ntyp,3)",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Array",
          "default": "read from pseudopotentials",
          "description": "Hubbard occupations is the number of electrons in the Hubbard manifold. By default they are initialized by reading the occupations from pseudopotentials. If specified from the input, then the values read from the pseudopotentials will be overwritten. The second index of the Hubbard_occ array corresponds to the Hubbard manifold number. It is possible to specify up to three Hubbard manifolds per Hubbard atom. However, if you want to specify three manifolds then the second and the third manifolds will be considered as one effective manifold (see Doc/Hubbard_input.pdf)",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Hubbard occupations is the number of electrons in the Hubbard manifold. By default they are initialized by reading the occupations from pseudopotentials. If specified from the input, then the values read from the pseudopotentials will be overwritten. The second index of the Hubbard_occ array corresponds to the Hubbard manifold number. It is possible to specify up to three Hubbard manifolds per Hubbard atom. However, if you want to specify three manifolds then the second and the third manifolds will be considered as one effective manifold (see Doc/Hubbard_input.pdf)"
        },
        "Hubbard_beta(i), i=1,ntyp": {
          "name": "Hubbard_beta(i), i=1,ntyp",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Array",
          "default": "0.D0 for all species",
          "description": "Hubbard_beta(i) is the perturbation (on atom i, in eV) used to compute J0 with the linear-response method of Cococcioni and de Gironcoli, PRB 71, 035105 (2005) (only for DFT+U or DFT+U+V). See also PRB 84, 115108 (2011) .",
          "options": [],
          "units": "i",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Hubbard_beta(i) is the perturbation (on atom i, in eV) used to compute J0 with the linear-response method of Cococcioni and de Gironcoli, PRB 71, 035105 (2005) (only for DFT+U or DFT+U+V). See also PRB 84, 115108 (2011) ."
        },
        "starting_ns_eigenvalue(m,ispin,ityp), (m,ispin,ityp) = (1,1,1) . . . (2*lmax+1,nspin or npol,ntyp)": {
          "name": "starting_ns_eigenvalue(m,ispin,ityp), (m,ispin,ityp) = (1,1,1) . . . (2*lmax+1,nspin or npol,ntyp)",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Array",
          "default": "-1.d0 that means NOT SET",
          "description": "In the first iteration of an DFT+U run it overwrites the m-th eigenvalue of the ns occupation matrix for the ispin component of atomic species ityp. For the noncollinear case, the ispin index runs up to npol=2 The value lmax is given by the maximum angular momentum number to which the Hubbard U is applied. Leave unchanged eigenvalues that are not set. This is useful to suggest the desired orbital occupations when the default choice takes another path.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "In the first iteration of an DFT+U run it overwrites the m-th eigenvalue of the ns occupation matrix for the ispin component of atomic species ityp. For the noncollinear case, the ispin index runs up to npol=2 The value lmax is given by the maximum angular momentum number to which the Hubbard U is applied. Leave unchanged eigenvalues that are not set. This is useful to suggest the desired orbital occupations when the default choice takes another path."
        },
        "dmft": {
          "name": "dmft",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If true, nscf calculation will exit in restart mode, scf calculation will restart from there if DMFT updates are provided as hdf5 archive. Scf calculation should be used only with electron_maxstep = 1. K_POINTS have to be identical and given explicitly with nosym .",
          "options": [],
          "units": "restart",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If true, nscf calculation will exit in restart mode, scf calculation will restart from there if DMFT updates are provided as hdf5 archive. Scf calculation should be used only with electron_maxstep = 1. K_POINTS have to be identical and given explicitly with nosym ."
        },
        "dmft_prefix": {
          "name": "dmft_prefix",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "String",
          "default": "prefix",
          "description": "prepended to hdf5 archive: dmft_prefix.h5 DMFT update should be provided in group/dataset as: - dft_misc_input/band_window with dimension [1, number of k-points, 2 (real + complex)] - dft_update/delta_N with dimension [number of k-points, number of correlated orbitals, number of correlated orbitals, 2 (real + complex)]",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "prepended to hdf5 archive: dmft_prefix.h5 DMFT update should be provided in group/dataset as: - dft_misc_input/band_window with dimension [1, number of k-points, 2 (real + complex)] - dft_update/delta_N with dimension [number of k-points, number of correlated orbitals, number of correlated orbitals, 2 (real + complex)]"
        },
        "ensemble_energies": {
          "name": "ensemble_energies",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".false.",
          "description": "If ensemble_energies = .true., an ensemble of xc energies is calculated non-selfconsistently for perturbed exchange-enhancement factors and LDA vs. PBE correlation ratios after each converged electronic ground state calculation. Ensemble energies can be analyzed with the 'bee' utility included with libbeef. Requires linking against libbeef. input_dft must be set to a BEEF-type functional (e.g. input_dft = 'BEEF-vdW')",
          "options": [
            "'bee'",
            "'BEEF-vdW'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If ensemble_energies = .true., an ensemble of xc energies is calculated non-selfconsistently for perturbed exchange-enhancement factors and LDA vs. PBE correlation ratios after each converged electronic ground state calculation. Ensemble energies can be analyzed with the 'bee' utility included with libbeef. Requires linking against libbeef. input_dft must be set to a BEEF-type functional (e.g. input_dft = 'BEEF-vdW')"
        },
        "edir": {
          "name": "edir",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": null,
          "description": "The direction of the electric field or dipole correction is parallel to the bg(:,edir) reciprocal lattice vector, so the potential is constant in planes defined by FFT grid points; edir = 1, 2 or 3. Used only if tefield is .TRUE.",
          "options": [],
          "units": "planes",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The direction of the electric field or dipole correction is parallel to the bg(:,edir) reciprocal lattice vector, so the potential is constant in planes defined by FFT grid points; edir = 1, 2 or 3. Used only if tefield is .TRUE."
        },
        "emaxpos": {
          "name": "emaxpos",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.5D0",
          "description": "Position of the maximum of the saw-like potential along crystal axis edir , within the unit cell (see below), 0 < emaxpos < 1 Used only if tefield is .TRUE.",
          "options": [],
          "units": null,
          "range": "0 < x < 1",
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Position of the maximum of the saw-like potential along crystal axis edir , within the unit cell (see below), 0 < emaxpos < 1 Used only if tefield is .TRUE."
        },
        "eopreg": {
          "name": "eopreg",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.1D0",
          "description": "Zone in the unit cell where the saw-like potential decreases. ( see below, 0 < eopreg < 1 ). Used only if tefield is .TRUE.",
          "options": [],
          "units": "the",
          "range": "0 < x < 1",
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Zone in the unit cell where the saw-like potential decreases. ( see below, 0 < eopreg < 1 ). Used only if tefield is .TRUE."
        },
        "eamp": {
          "name": "eamp",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.001 a.u.",
          "description": "Amplitude of the electric field, in ***Hartree*** a.u.; 1 a.u. = 51.4220632*10^10 V/m. Used only if tefield ==.TRUE. The saw-like potential increases with slope eamp in the region from ( emaxpos + eopreg -1) to ( emaxpos ), then decreases to 0 until ( emaxpos + eopreg ), in units of the crystal vector edir . Important: the change of slope of this potential must be located in the empty region, or else unphysical forces will result.",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Amplitude of the electric field, in ***Hartree*** a.u.; 1 a.u. = 51.4220632*10^10 V/m. Used only if tefield ==.TRUE. The saw-like potential increases with slope eamp in the region from ( emaxpos + eopreg -1) to ( emaxpos ), then decreases to 0 until ( emaxpos + eopreg ), in units of the crystal vector edir . Important: the change of slope of this potential must be located in the empty region, or else unphysical forces will result."
        },
        "angle1(i), i=1,ntyp": {
          "name": "angle1(i), i=1,ntyp",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Array",
          "default": null,
          "description": "The angle expressed in degrees between the initial magnetization and the z-axis. For noncollinear calculations only; index i runs over the atom types.",
          "options": [],
          "units": "degrees",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The angle expressed in degrees between the initial magnetization and the z-axis. For noncollinear calculations only; index i runs over the atom types."
        },
        "angle2(i), i=1,ntyp": {
          "name": "angle2(i), i=1,ntyp",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Array",
          "default": null,
          "description": "The angle expressed in degrees between the projection of the initial magnetization on x-y plane and the x-axis. For noncollinear calculations only.",
          "options": [],
          "units": "degrees",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The angle expressed in degrees between the projection of the initial magnetization on x-y plane and the x-axis. For noncollinear calculations only."
        },
        "lforcet": {
          "name": "lforcet",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": null,
          "description": "When starting a non collinear calculation using an existing density file from a collinear lsda calculation assumes previous density points in z direction and rotates it in the direction described by angle1 and angle2 variables for atomic type 1",
          "options": [],
          "units": "z",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "When starting a non collinear calculation using an existing density file from a collinear lsda calculation assumes previous density points in z direction and rotates it in the direction described by angle1 and angle2 variables for atomic type 1"
        },
        "constrained_magnetization": {
          "name": "constrained_magnetization",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "String",
          "default": "'none'",
          "description": "Used to perform constrained calculations in magnetic systems. Currently available choices: no constraint total magnetization is constrained by adding a penalty functional to the total energy: LAMBDA * SUM_{i} ( magnetization(i) - fixed_magnetization(i) )**2 where the sum over i runs over the three components of the magnetization. Lambda is a real number (see below). Noncolinear case only. Use tot_magnetization for LSDA atomic magnetization are constrained to the defined starting magnetization adding a penalty: LAMBDA * SUM_{i,itype} ( magnetic_moment(i,itype) - mcons(i,itype) )**2 where i runs over the cartesian components (or just z in the collinear case) and itype over the types (1-ntype). mcons(:,:) array is defined from starting_magnetization, (also from angle1, angle2 in the noncollinear case). lambda is a real number the angle theta of the total magnetization with the z axis (theta = fixed_magnetization(3)) is constrained: LAMBDA * ( arccos(magnetization(3)/mag_tot) - theta )**2 where mag_tot is the modulus of the total magnetization. not all the components of the atomic magnetic moment are constrained but only the cosine of angle1, and the penalty functional is: LAMBDA * SUM_{itype} ( mag_mom(3,itype)/mag_mom_tot - cos(angle1(ityp)) )**2 N.B.: symmetrization may prevent to reach the desired orientation of the magnetization. Try not to start with very highly symmetric configurations or use the nosym flag (only as a last remedy)",
          "options": [
            "'none'",
            "'total'",
            "'atomic'",
            "'total direction'",
            "'atomic direction'"
          ],
          "units": "magnetic",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Used to perform constrained calculations in magnetic systems. Currently available choices: no constraint total magnetization is constrained by adding a penalty functional to the total energy: LAMBDA * SUM_{i} ( magnetization(i) - fixed_magnetization(i) )**2 where the sum over i runs over the three components of the magnetization. Lambda is a real number (see below). Noncolinear case only. Use tot_magnetization for LSDA atomic magnetization are constrained to the defined starting magnetization adding a penalty: LAMBDA * SUM_{i,itype} ( magnetic_moment(i,itype) - mcons(i,itype) )**2 where i runs over the cartesian components (or just z in the collinear case) and itype over the types (1-ntype). mcons(:,:) array is defined from starting_magnetization, (also from angle1, angle2 in the noncollinear case). lambda is a real number the angle theta of the total magnetization with the z axis (theta = fixed_magnetization(3)) is constrained: LAMBDA * ( arccos(magnetization(3)/mag_tot) - theta )**2 where mag_tot is the modulus of the total magnetization. not all the components of the atomic magnetic moment are constrained but only the cosine of angle1, and the penalty functional is: LAMBDA * SUM_{itype} ( mag_mom(3,itype)/mag_mom_tot - cos(angle1(ityp)) )**2 N.B.: symmetrization may prevent to reach the desired orientation of the magnetization. Try not to start with very highly symmetric configurations or use the nosym flag (only as a last remedy)"
        },
        "fixed_magnetization(i), i=1,3": {
          "name": "fixed_magnetization(i), i=1,3",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Array",
          "default": "0.d0",
          "description": "total magnetization vector (x,y,z components) to be kept fixed when constrained_magnetization =='total'",
          "options": [
            "'total'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "total magnetization vector (x,y,z components) to be kept fixed when constrained_magnetization =='total'"
        },
        "lambda": {
          "name": "lambda",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.d0",
          "description": "parameter used for constrained_magnetization calculations N.B.: if the scf calculation does not converge, try to reduce lambda to obtain convergence, then restart the run with a larger lambda",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "parameter used for constrained_magnetization calculations N.B.: if the scf calculation does not converge, try to reduce lambda to obtain convergence, then restart the run with a larger lambda"
        },
        "report": {
          "name": "report",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "-1",
          "description": "determines when atomic magnetic moments are printed on output: report = 0 never report =-1 at the beginning of the scf and at convergence report = N as -1, plus every N scf iterations",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "determines when atomic magnetic moments are printed on output: report = 0 never report =-1 at the beginning of the scf and at convergence report = N as -1, plus every N scf iterations"
        },
        "lspinorb": {
          "name": "lspinorb",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": null,
          "description": "if .TRUE. the noncollinear code can use a pseudopotential with spin-orbit.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "if .TRUE. the noncollinear code can use a pseudopotential with spin-orbit."
        },
        "assume_isolated": {
          "name": "assume_isolated",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "String",
          "default": "'none'",
          "description": "Used to perform calculation assuming the system to be isolated (a molecule or a cluster in a 3D supercell). Currently available choices: (default): regular periodic calculation w/o any correction. the Makov-Payne correction to the total energy is computed. An estimate of the vacuum level is also calculated so that eigenvalues can be properly aligned. ONLY FOR CUBIC SYSTEMS ( ibrav =1,2,3). Theory: G.Makov, and M.C.Payne, \"Periodic boundary conditions in ab initio calculations\" , PRB 51, 4014 (1995) . Martyna-Tuckerman correction to both total energy and scf potential. Adapted from: G.J. Martyna, and M.E. Tuckerman, \"A reciprocal space based method for treating long range interactions in ab-initio and force-field-based calculation in clusters\", J. Chem. Phys. 110, 2810 (1999), doi:10.1063/1.477923 . Effective Screening Medium Method. For polarized or charged slab calculation, embeds the simulation cell within an effective semi- infinite medium in the perpendicular direction (along z). Embedding regions can be vacuum or semi-infinite metal electrodes (use esm_bc to choose boundary conditions). If between two electrodes, an optional electric field ( esm_efield ) may be applied. Method described in M. Otani and O. Sugino, \"First-principles calculations of charged surfaces and interfaces: A plane-wave nonrepeated slab approach\", PRB 73, 115407 (2006) . NB: - Two dimensional (xy plane) average charge density and electrostatic potentials are printed out to 'prefix.esm1'. - Requires cell with a_3 lattice vector along z, normal to the xy plane, with the slab centered around z=0. - For bc2 with an electric field and bc3 boundary conditions, the inversion symmetry along z-direction is automatically eliminated. - In case of calculation='vc-relax', use cell_dofree ='2Dxy' or other parameters so that c-vector along z-axis should not be moved. See esm_bc , esm_efield , esm_w , esm_nfit . Truncation of the Coulomb interaction in the z direction for structures periodic in the x-y plane. Total energy, forces and stresses are computed in a two-dimensional framework. Linear-response calculations () done on top of a self-consistent calculation with this flag will automatically be performed in the 2D framework as well. Please refer to: Sohier, T., Calandra, M., & Mauri, F. (2017), \"Density functional perturbation theory for gated two-dimensional heterostructures: Theoretical developments and application to flexural phonons in graphene\", PRB, 96, 075448 (2017) . NB: - The length of the unit-cell along the z direction should be larger than twice the thickness of the 2D material (including electrons). A reasonable estimate for a layer's thickness could be the interlayer distance in the corresponding layered bulk material. Otherwise, the atomic thickness + 10 bohr should be a safe estimate. There is also a lower limit of 20 bohr imposed by the cutoff radius used to read pseudopotentials (see read_pseudo.f90 in Modules). - As for ESM above, only in-plane stresses make sense and one should use cell_dofree = '2Dxy' in a vc-relax calculation.",
          "options": [
            "'none'",
            "'makov-payne'",
            "'m-p'",
            "'mp'",
            "'martyna-tuckerman'",
            "'m-t'",
            "'mt'",
            "'esm'",
            "'2D'",
            "'prefix.esm1'",
            "'vc-relax'",
            "'2Dxy'",
            "'s thickness could be the interlayer distance in the corresponding layered bulk material. Otherwise, the atomic thickness + 10 bohr should be a safe estimate. There is also a lower limit of 20 bohr imposed by the cutoff radius used to read pseudopotentials (see read_pseudo.f90 in Modules). - As for ESM above, only in-plane stresses make sense and one should use cell_dofree = '"
          ],
          "units": "a",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Used to perform calculation assuming the system to be isolated (a molecule or a cluster in a 3D supercell). Currently available choices: (default): regular periodic calculation w/o any correction. the Makov-Payne correction to the total energy is computed. An estimate of the vacuum level is also calculated so that eigenvalues can be properly aligned. ONLY FOR CUBIC SYSTEMS ( ibrav =1,2,3). Theory: G.Makov, and M.C.Payne, \"Periodic boundary conditions in ab initio calculations\" , PRB 51, 4014 (1995) . Martyna-Tuckerman correction to both total energy and scf potential. Adapted from: G.J. Martyna, and M.E. Tuckerman, \"A reciprocal space based method for treating long range interactions in ab-initio and force-field-based calculation in clusters\", J. Chem. Phys. 110, 2810 (1999), doi:10.1063/1.477923 . Effective Screening Medium Method. For polarized or charged slab calculation, embeds the simulation cell within an effective semi- infinite medium in the perpendicular direction (along z). Embedding regions can be vacuum or semi-infinite metal electrodes (use esm_bc to choose boundary conditions). If between two electrodes, an optional electric field ( esm_efield ) may be applied. Method described in M. Otani and O. Sugino, \"First-principles calculations of charged surfaces and interfaces: A plane-wave nonrepeated slab approach\", PRB 73, 115407 (2006) . NB: - Two dimensional (xy plane) average charge density and electrostatic potentials are printed out to 'prefix.esm1'. - Requires cell with a_3 lattice vector along z, normal to the xy plane, with the slab centered around z=0. - For bc2 with an electric field and bc3 boundary conditions, the inversion symmetry along z-direction is automatically eliminated. - In case of calculation='vc-relax', use cell_dofree ='2Dxy' or other parameters so that c-vector along z-axis should not be moved. See esm_bc , esm_efield , esm_w , esm_nfit . Truncation of the Coulomb interaction in the z direction for structures periodic in the x-y plane. Total energy, forces and stresses are computed in a two-dimensional framework. Linear-response calculations () done on top of a self-consistent calculation with this flag will automatically be performed in the 2D framework as well. Please refer to: Sohier, T., Calandra, M., & Mauri, F. (2017), \"Density functional perturbation theory for gated two-dimensional heterostructures: Theoretical developments and application to flexural phonons in graphene\", PRB, 96, 075448 (2017) . NB: - The length of the unit-cell along the z direction should be larger than twice the thickness of the 2D material (including electrons). A reasonable estimate for a layer's thickness could be the interlayer distance in the corresponding layered bulk material. Otherwise, the atomic thickness + 10 bohr should be a safe estimate. There is also a lower limit of 20 bohr imposed by the cutoff radius used to read pseudopotentials (see read_pseudo.f90 in Modules). - As for ESM above, only in-plane stresses make sense and one should use cell_dofree = '2Dxy' in a vc-relax calculation."
        },
        "esm_bc": {
          "name": "esm_bc",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "String",
          "default": "'pbc'",
          "description": "If assume_isolated = 'esm', determines the boundary conditions used for either side of the slab. Currently available choices: (default): regular periodic calculation (no ESM). Vacuum-slab-vacuum (open boundary conditions). Metal-slab-metal (dual electrode configuration). See also esm_efield . Vacuum-slab-metal",
          "options": [
            "'pbc'",
            "'bc1'",
            "'bc2'",
            "'bc3'",
            "'esm'"
          ],
          "units": "default",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "assume_isolated = 'esm'"
            ]
          },
          "rawText": "If assume_isolated = 'esm', determines the boundary conditions used for either side of the slab. Currently available choices: (default): regular periodic calculation (no ESM). Vacuum-slab-vacuum (open boundary conditions). Metal-slab-metal (dual electrode configuration). See also esm_efield . Vacuum-slab-metal"
        },
        "esm_w": {
          "name": "esm_w",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.d0",
          "description": "If assume_isolated = 'esm', determines the position offset [in a.u.] of the start of the effective screening region, measured relative to the cell edge. (ESM region begins at z = +/- [L_z/2 + esm_w] ).",
          "options": [
            "'esm'"
          ],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "assume_isolated = 'esm'"
            ]
          },
          "rawText": "If assume_isolated = 'esm', determines the position offset [in a.u.] of the start of the effective screening region, measured relative to the cell edge. (ESM region begins at z = +/- [L_z/2 + esm_w] )."
        },
        "esm_efield": {
          "name": "esm_efield",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.d0",
          "description": "If assume_isolated = 'esm' and esm_bc = 'bc2', gives the magnitude of the electric field [Ry/a.u.] to be applied between semi-infinite ESM electrodes.",
          "options": [
            "'esm'",
            "'bc2'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "assume_isolated = 'esm'"
            ]
          },
          "rawText": "If assume_isolated = 'esm' and esm_bc = 'bc2', gives the magnitude of the electric field [Ry/a.u.] to be applied between semi-infinite ESM electrodes."
        },
        "esm_nfit": {
          "name": "esm_nfit",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "4",
          "description": "If assume_isolated = 'esm', gives the number of z-grid points for the polynomial fit along the cell edge.",
          "options": [
            "'esm'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "assume_isolated = 'esm'"
            ]
          },
          "rawText": "If assume_isolated = 'esm', gives the number of z-grid points for the polynomial fit along the cell edge."
        },
        "lgcscf": {
          "name": "lgcscf",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE. perform a constant bias potential (constant-mu) calculation with Grand-Canonical SCF. (JCP 146, 114104 (2017), R.Sundararaman, et al.) NB: - The total energy displayed in output includes the potentiostat contribution (-mu*N). - assume_isolated = 'esm' and esm_bc = 'bc2' or 'bc3' must be set in SYSTEM namelist. - ESM-RISM is also supported ( assume_isolated = 'esm' and esm_bc = 'bc1' and trism = .TRUE.). - mixing_mode has to be 'TF' or 'local-TF', also its default is 'TF.' - The default of mixing_beta is 0.1 with ESM-RISM, 0.2 without ESM-RISM. - The default of diago_thr_init is 1.D-5. - diago_full_acc is always .TRUE. . - diago_rmm_conv is always .TRUE. .",
          "options": [
            "'esm'",
            "'bc2'",
            "'bc3'",
            "'bc1'",
            "'TF'",
            "'local-TF'",
            "'TF.'"
          ],
          "units": "constant-mu",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE. perform a constant bias potential (constant-mu) calculation with Grand-Canonical SCF. (JCP 146, 114104 (2017), R.Sundararaman, et al.) NB: - The total energy displayed in output includes the potentiostat contribution (-mu*N). - assume_isolated = 'esm' and esm_bc = 'bc2' or 'bc3' must be set in SYSTEM namelist. - ESM-RISM is also supported ( assume_isolated = 'esm' and esm_bc = 'bc1' and trism = .TRUE.). - mixing_mode has to be 'TF' or 'local-TF', also its default is 'TF.' - The default of mixing_beta is 0.1 with ESM-RISM, 0.2 without ESM-RISM. - The default of diago_thr_init is 1.D-5. - diago_full_acc is always .TRUE. . - diago_rmm_conv is always .TRUE. ."
        },
        "gcscf_mu": {
          "name": "gcscf_mu",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": null,
          "description": "The target Fermi energy (eV) of GC-SCF. One can start with appropriate total charge of the system by giving tot_charge .",
          "options": [],
          "units": "eV",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The target Fermi energy (eV) of GC-SCF. One can start with appropriate total charge of the system by giving tot_charge ."
        },
        "gcscf_conv_thr": {
          "name": "gcscf_conv_thr",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D-2",
          "description": "Convergence threshold of Fermi energy (eV) for GC-SCF.",
          "options": [],
          "units": "eV",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Convergence threshold of Fermi energy (eV) for GC-SCF."
        },
        "gcscf_beta": {
          "name": "gcscf_beta",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.05D0",
          "description": "Mixing factor for GC-SCF. Larger values are recommended, if systems with small DOS on Fermi surface as graphite.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Mixing factor for GC-SCF. Larger values are recommended, if systems with small DOS on Fermi surface as graphite."
        },
        "vdw_corr": {
          "name": "vdw_corr",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "String",
          "default": "'none'",
          "description": "Type of the van der Waals correction. Allowed values: Semiempirical Grimme's DFT-D2. Optional variables: london_s6 , london_rcut , london_c6 , london_rvdw S. Grimme, J. Comp. Chem. 27, 1787 (2006), doi:10.1002/jcc.20495 V. Barone et al., J. Comp. Chem. 30, 934 (2009), doi:10.1002/jcc.21112 Semiempirical Grimme's DFT-D3. Optional variables: dftd3_version , dftd3_threebody S. Grimme et al, J. Chem. Phys 132, 154104 (2010), doi:10.1063/1.3382344 Tkatchenko-Scheffler dispersion corrections with first-principle derived C6 coefficients. Optional variables: ts_vdw_econv_thr , ts_vdw_isolated See A. Tkatchenko and M. Scheffler, PRL 102, 073005 (2009) . J. Hermann et al., J. Chem. Phys. 159, 174802 (2023), doi:10.1063/5.0170972 Many-body dipersion (MBD) correction to long-range interactions. Optional variables: ts_vdw_isolated A. Ambrosetti et al., J. Chem. Phys. 140, 18A508 (2014), doi:10.1063/1.4865104 J. Hermann et al., J. Chem. Phys. 159, 174802 (2023), doi:10.1063/5.0170972 Exchange-hole dipole-moment model. Optional variables: xdm_a1 , xdm_a2 A. D. Becke et al., J. Chem. Phys. 127, 154108 (2007), doi:10.1063/1.2795701 A. Otero de la Roza et al., J. Chem. Phys. 136, 174109 (2012), doi:10.1063/1.4705760 Note that non-local functionals (eg vdw-DF) are NOT specified here but in input_dft",
          "options": [
            "'grimme-d2'",
            "'Grimme-D2'",
            "'DFT-D'",
            "'dft-d'",
            "'grimme-d3'",
            "'Grimme-D3'",
            "'DFT-D3'",
            "'dft-d3'",
            "'TS'",
            "'ts'",
            "'ts-vdw'",
            "'ts-vdW'",
            "'tkatchenko-scheffler'",
            "'MBD'",
            "'mbd'",
            "'many-body-dispersion'",
            "'mbd_vdw'",
            "'XDM'",
            "'xdm'",
            "'s DFT-D2. Optional variables: london_s6 , london_rcut , london_c6 , london_rvdw S. Grimme, J. Comp. Chem. 27, 1787 (2006), doi:10.1002/jcc.20495 V. Barone et al., J. Comp. Chem. 30, 934 (2009), doi:10.1002/jcc.21112 Semiempirical Grimme'"
          ],
          "units": "2006",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Type of the van der Waals correction. Allowed values: Semiempirical Grimme's DFT-D2. Optional variables: london_s6 , london_rcut , london_c6 , london_rvdw S. Grimme, J. Comp. Chem. 27, 1787 (2006), doi:10.1002/jcc.20495 V. Barone et al., J. Comp. Chem. 30, 934 (2009), doi:10.1002/jcc.21112 Semiempirical Grimme's DFT-D3. Optional variables: dftd3_version , dftd3_threebody S. Grimme et al, J. Chem. Phys 132, 154104 (2010), doi:10.1063/1.3382344 Tkatchenko-Scheffler dispersion corrections with first-principle derived C6 coefficients. Optional variables: ts_vdw_econv_thr , ts_vdw_isolated See A. Tkatchenko and M. Scheffler, PRL 102, 073005 (2009) . J. Hermann et al., J. Chem. Phys. 159, 174802 (2023), doi:10.1063/5.0170972 Many-body dipersion (MBD) correction to long-range interactions. Optional variables: ts_vdw_isolated A. Ambrosetti et al., J. Chem. Phys. 140, 18A508 (2014), doi:10.1063/1.4865104 J. Hermann et al., J. Chem. Phys. 159, 174802 (2023), doi:10.1063/5.0170972 Exchange-hole dipole-moment model. Optional variables: xdm_a1 , xdm_a2 A. D. Becke et al., J. Chem. Phys. 127, 154108 (2007), doi:10.1063/1.2795701 A. Otero de la Roza et al., J. Chem. Phys. 136, 174109 (2012), doi:10.1063/1.4705760 Note that non-local functionals (eg vdw-DF) are NOT specified here but in input_dft"
        },
        "london": {
          "name": "london",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": null,
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": null
        },
        "london_s6": {
          "name": "london_s6",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.75",
          "description": "global scaling parameter for DFT-D. Default is good for PBE.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "global scaling parameter for DFT-D. Default is good for PBE."
        },
        "london_c6(i), i=1,ntyp": {
          "name": "london_c6(i), i=1,ntyp",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Array",
          "default": "standard Grimme-D2 values",
          "description": "atomic C6 coefficient of each atom type ( if not specified default values from S. Grimme, J. Comp. Chem. 27, 1787 (2006), doi:10.1002/jcc.20495 are used; see file Modules/mm_dispersion.f90 )",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "atomic C6 coefficient of each atom type ( if not specified default values from S. Grimme, J. Comp. Chem. 27, 1787 (2006), doi:10.1002/jcc.20495 are used; see file Modules/mm_dispersion.f90 )"
        },
        "london_rvdw(i), i=1,ntyp": {
          "name": "london_rvdw(i), i=1,ntyp",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Array",
          "default": "standard Grimme-D2 values",
          "description": "atomic vdw radii of each atom type ( if not specified default values from S. Grimme, J. Comp. Chem. 27, 1787 (2006), doi:10.1002/jcc.20495 are used; see file Modules/mm_dispersion.f90 )",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "atomic vdw radii of each atom type ( if not specified default values from S. Grimme, J. Comp. Chem. 27, 1787 (2006), doi:10.1002/jcc.20495 are used; see file Modules/mm_dispersion.f90 )"
        },
        "london_rcut": {
          "name": "london_rcut",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "200",
          "description": "cutoff radius (a.u.) for dispersion interactions",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "cutoff radius (a.u.) for dispersion interactions"
        },
        "dftd3_version": {
          "name": "dftd3_version",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "3",
          "description": "Version of Grimme implementation of Grimme-D3: Original Grimme-D2 parametrization Grimme-D3 (zero damping) Grimme-D3 (BJ damping) Grimme-D3M (zero damping) Grimme-D3M (BJ damping) NOTE: not all functionals are parametrized.",
          "options": [
            "dftd3_version = 2",
            "dftd3_version = 3",
            "dftd3_version = 4",
            "dftd3_version = 5",
            "dftd3_version = 6"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Version of Grimme implementation of Grimme-D3: Original Grimme-D2 parametrization Grimme-D3 (zero damping) Grimme-D3 (BJ damping) Grimme-D3M (zero damping) Grimme-D3M (BJ damping) NOTE: not all functionals are parametrized."
        },
        "dftd3_threebody": {
          "name": "dftd3_threebody",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": "TRUE",
          "description": "Turn three-body terms in Grimme-D3 on. If .false. two-body contributions only are computed, using two-body parameters of Grimme-D3. If dftd3_version=2, three-body contribution is always disabled.",
          "options": [],
          "units": "Grimme-D3",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "dftd3_version = 2"
            ]
          },
          "rawText": "Turn three-body terms in Grimme-D3 on. If .false. two-body contributions only are computed, using two-body parameters of Grimme-D3. If dftd3_version=2, three-body contribution is always disabled."
        },
        "ts_vdw_econv_thr": {
          "name": "ts_vdw_econv_thr",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D-6",
          "description": "Optional: controls the convergence of the vdW energy (and forces). The default value is a safe choice, likely too safe, but you do not gain much in increasing it",
          "options": [],
          "units": "increasing",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Optional: controls the convergence of the vdW energy (and forces). The default value is a safe choice, likely too safe, but you do not gain much in increasing it"
        },
        "ts_vdw_isolated": {
          "name": "ts_vdw_isolated",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "Optional: set it to .TRUE. when computing the Tkatchenko-Scheffler vdW energy or the Many-Body dispersion (MBD) energy for an isolated (non-periodic) system.",
          "options": [],
          "units": "MBD",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Optional: set it to .TRUE. when computing the Tkatchenko-Scheffler vdW energy or the Many-Body dispersion (MBD) energy for an isolated (non-periodic) system."
        },
        "xdm": {
          "name": "xdm",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": null,
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": null
        },
        "xdm_a1": {
          "name": "xdm_a1",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.6836",
          "description": "Damping function parameter a1 (adimensional). It is NOT necessary to give a value if the functional is one of B86bPBE, PW86PBE, PBE, BLYP. For functionals in this list, the coefficients are given in: https://github.com/aoterodelaroza/postg/blob/master/xdm.param or https://erin-r-johnson.github.io/software/ A. Otero de la Roza, E. R. Johnson, J. Chem. Phys. 138, 204109 (2013), doi:10.1063/1.4705760",
          "options": [],
          "units": "adimensional",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Damping function parameter a1 (adimensional). It is NOT necessary to give a value if the functional is one of B86bPBE, PW86PBE, PBE, BLYP. For functionals in this list, the coefficients are given in: https://github.com/aoterodelaroza/postg/blob/master/xdm.param or https://erin-r-johnson.github.io/software/ A. Otero de la Roza, E. R. Johnson, J. Chem. Phys. 138, 204109 (2013), doi:10.1063/1.4705760"
        },
        "xdm_a2": {
          "name": "xdm_a2",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.5045",
          "description": "Damping function parameter a2 (angstrom). It is NOT necessary to give a value if the functional is one of B86bPBE, PW86PBE, PBE, BLYP. For functionals in this list, the coefficients are given in: https://github.com/aoterodelaroza/postg/blob/master/xdm.param or https://erin-r-johnson.github.io/software/ A. Otero de la Roza, E. R. Johnson, J. Chem. Phys. 138, 204109 (2013), doi:10.1063/1.4705760",
          "options": [],
          "units": "angstrom",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Damping function parameter a2 (angstrom). It is NOT necessary to give a value if the functional is one of B86bPBE, PW86PBE, PBE, BLYP. For functionals in this list, the coefficients are given in: https://github.com/aoterodelaroza/postg/blob/master/xdm.param or https://erin-r-johnson.github.io/software/ A. Otero de la Roza, E. R. Johnson, J. Chem. Phys. 138, 204109 (2013), doi:10.1063/1.4705760"
        },
        "space_group": {
          "name": "space_group",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "0",
          "description": "The number of the space group of the crystal, as given in the International Tables of Crystallography A (ITA). This allows to give in input only the inequivalent atomic positions. The positions of all the symmetry equivalent atoms are calculated by the code. Used only when the atomic positions are of type crystal_sg. See also uniqueb , origin_choice , rhombohedral",
          "options": [],
          "units": "ITA",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The number of the space group of the crystal, as given in the International Tables of Crystallography A (ITA). This allows to give in input only the inequivalent atomic positions. The positions of all the symmetry equivalent atoms are calculated by the code. Used only when the atomic positions are of type crystal_sg. See also uniqueb , origin_choice , rhombohedral"
        },
        "uniqueb": {
          "name": "uniqueb",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "Used only for monoclinic lattices. If .TRUE. the b unique ibrav (-12 or -13) are used, and symmetry equivalent positions are chosen assuming that the twofold axis or the mirror normal is parallel to the b axis. If .FALSE. it is parallel to the c axis.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Used only for monoclinic lattices. If .TRUE. the b unique ibrav (-12 or -13) are used, and symmetry equivalent positions are chosen assuming that the twofold axis or the mirror normal is parallel to the b axis. If .FALSE. it is parallel to the c axis."
        },
        "origin_choice": {
          "name": "origin_choice",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "1",
          "description": "Used only for space groups that in the ITA allow the use of two different origins. origin_choice =1, means the first origin, while origin_choice =2 is the second origin.",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Used only for space groups that in the ITA allow the use of two different origins. origin_choice =1, means the first origin, while origin_choice =2 is the second origin."
        },
        "rhombohedral": {
          "name": "rhombohedral",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".TRUE.",
          "description": "Used only for rhombohedral space groups. When .TRUE. the coordinates of the inequivalent atoms are given with respect to the rhombohedral axes, when .FALSE. the coordinates of the inequivalent atoms are given with respect to the hexagonal axes. They are converted internally to the rhombohedral axes and ibrav =5 is used in both cases.",
          "options": [],
          "units": "both",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Used only for rhombohedral space groups. When .TRUE. the coordinates of the inequivalent atoms are given with respect to the rhombohedral axes, when .FALSE. the coordinates of the inequivalent atoms are given with respect to the hexagonal axes. They are converted internally to the rhombohedral axes and ibrav =5 is used in both cases."
        },
        "zgate": {
          "name": "zgate",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.5",
          "description": "used only if gate = .TRUE. Specifies the position of the charged plate which represents the counter charge in doped systems ( tot_charge .ne. 0). In units of the unit cell length in z direction, zgate in ]0,1[ Details of the gate potential can be found in T. Brumme, M. Calandra, F. Mauri; PRB 89, 245406 (2014) .",
          "options": [],
          "units": "doped",
          "range": "0..1",
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "used only if gate = .TRUE. Specifies the position of the charged plate which represents the counter charge in doped systems ( tot_charge .ne. 0). In units of the unit cell length in z direction, zgate in ]0,1[ Details of the gate potential can be found in T. Brumme, M. Calandra, F. Mauri; PRB 89, 245406 (2014) ."
        },
        "relaxz": {
          "name": "relaxz",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "used only if gate = .TRUE. Allows the relaxation of the system towards the charged plate. Use carefully and utilize either a layer of fixed atoms or a potential barrier ( block =.TRUE.) to avoid the atoms moving to the position of the plate or the dipole of the dipole correction ( dipfield =.TRUE.).",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "used only if gate = .TRUE. Allows the relaxation of the system towards the charged plate. Use carefully and utilize either a layer of fixed atoms or a potential barrier ( block =.TRUE.) to avoid the atoms moving to the position of the plate or the dipole of the dipole correction ( dipfield =.TRUE.)."
        },
        "block": {
          "name": "block",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "used only if gate = .TRUE. Adds a potential barrier to the total potential seen by the electrons to mimic a dielectric in field effect configuration and/or to avoid electrons spilling into the vacuum region for electron doping. Potential barrier is from block_1 to block_2 and has a height of block_height. If dipfield = .TRUE. then eopreg is used for a smooth increase and decrease of the potential barrier.",
          "options": [],
          "units": "field",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "used only if gate = .TRUE. Adds a potential barrier to the total potential seen by the electrons to mimic a dielectric in field effect configuration and/or to avoid electrons spilling into the vacuum region for electron doping. Potential barrier is from block_1 to block_2 and has a height of block_height. If dipfield = .TRUE. then eopreg is used for a smooth increase and decrease of the potential barrier."
        },
        "block_1": {
          "name": "block_1",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.45",
          "description": "used only if gate = .TRUE. and block = .TRUE. lower beginning of the potential barrier, in units of the unit cell size along z, block_1 in ]0,1[",
          "options": [],
          "units": "units",
          "range": "0..1",
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "used only if gate = .TRUE. and block = .TRUE. lower beginning of the potential barrier, in units of the unit cell size along z, block_1 in ]0,1["
        },
        "block_2": {
          "name": "block_2",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.55",
          "description": "used only if gate = .TRUE. and block = .TRUE. upper beginning of the potential barrier, in units of the unit cell size along z, block_2 in ]0,1[",
          "options": [],
          "units": "units",
          "range": "0..1",
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "used only if gate = .TRUE. and block = .TRUE. upper beginning of the potential barrier, in units of the unit cell size along z, block_2 in ]0,1["
        },
        "block_height": {
          "name": "block_height",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.1",
          "description": "used only if gate = .TRUE. and block = .TRUE. Height of the potential barrier in Rydberg.",
          "options": [],
          "units": "Ry",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "used only if gate = .TRUE. and block = .TRUE. Height of the potential barrier in Rydberg."
        },
        "nextffield": {
          "name": "nextffield",
          "section": "& SYSTEM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "0",
          "description": "Number of activated external ionic force fields. See Doc/ExternalForceFields.tex for further explanation and parameterizations",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Number of activated external ionic force fields. See Doc/ExternalForceFields.tex for further explanation and parameterizations"
        }
      }
    },
    "& ELECTRONS": {
      "sectionType": "namelist",
      "variables": {
        "electron_maxstep": {
          "name": "electron_maxstep",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "100",
          "description": "maximum number of iterations in a scf step. If exact exchange is active, this will affect the inner loops.",
          "options": [],
          "units": "a",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "maximum number of iterations in a scf step. If exact exchange is active, this will affect the inner loops."
        },
        "exx_maxstep": {
          "name": "exx_maxstep",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "100",
          "description": "maximum number of outer iterations in a scf calculation with exact exchange.",
          "options": [],
          "units": "a",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "maximum number of outer iterations in a scf calculation with exact exchange."
        },
        "scf_must_converge": {
          "name": "scf_must_converge",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".TRUE.",
          "description": "If .false. do not stop molecular dynamics or ionic relaxation when electron_maxstep is reached. Use with care.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .false. do not stop molecular dynamics or ionic relaxation when electron_maxstep is reached. Use with care."
        },
        "conv_thr": {
          "name": "conv_thr",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D-6",
          "description": "Convergence threshold for selfconsistency: estimated energy error < conv_thr (note that conv_thr is extensive, like the total energy). For non-self-consistent calculations, conv_thr is used to set the default value of the threshold (ethr) for iterative diagonalization: see diago_thr_init",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Convergence threshold for selfconsistency: estimated energy error < conv_thr (note that conv_thr is extensive, like the total energy). For non-self-consistent calculations, conv_thr is used to set the default value of the threshold (ethr) for iterative diagonalization: see diago_thr_init"
        },
        "adaptive_thr": {
          "name": "adaptive_thr",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE",
          "description": "If .TRUE. this turns on the use of an adaptive conv_thr for the inner scf loops when using EXX.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE. this turns on the use of an adaptive conv_thr for the inner scf loops when using EXX."
        },
        "conv_thr_init": {
          "name": "conv_thr_init",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D-3",
          "description": "When adaptive_thr = .TRUE. this is the convergence threshold used for the first scf cycle.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "When adaptive_thr = .TRUE. this is the convergence threshold used for the first scf cycle."
        },
        "conv_thr_multi": {
          "name": "conv_thr_multi",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D-1",
          "description": "When adaptive_thr = .TRUE. the convergence threshold for each scf cycle is given by: max( conv_thr , conv_thr_multi * dexx )",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "When adaptive_thr = .TRUE. the convergence threshold for each scf cycle is given by: max( conv_thr , conv_thr_multi * dexx )"
        },
        "mixing_mode": {
          "name": "mixing_mode",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "String",
          "default": "'plain'",
          "description": "Available options are: charge density Broyden mixing as above, with simple Thomas-Fermi screening (for highly homogeneous systems) as above, with local-density-dependent TF screening (for highly inhomogeneous systems)",
          "options": [
            "'plain'",
            "'TF'",
            "'local-TF'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Available options are: charge density Broyden mixing as above, with simple Thomas-Fermi screening (for highly homogeneous systems) as above, with local-density-dependent TF screening (for highly inhomogeneous systems)"
        },
        "mixing_beta": {
          "name": "mixing_beta",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.7D0",
          "description": "mixing factor for self-consistency",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "mixing factor for self-consistency"
        },
        "mixing_ndim": {
          "name": "mixing_ndim",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "8",
          "description": "number of iterations used in mixing scheme. If you are tight with memory, you may reduce it to 4 or so.",
          "options": [],
          "units": "mixing",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "number of iterations used in mixing scheme. If you are tight with memory, you may reduce it to 4 or so."
        },
        "mixing_fixed_ns": {
          "name": "mixing_fixed_ns",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "0",
          "description": "For DFT+U : number of iterations with fixed ns ( ns is the atomic density appearing in the Hubbard term ).",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "For DFT+U : number of iterations with fixed ns ( ns is the atomic density appearing in the Hubbard term )."
        },
        "diagonalization": {
          "name": "diagonalization",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "String",
          "default": "'david'",
          "description": "Available options are: Davidson iterative diagonalization with overlap matrix (default). Fast, may in some rare cases fail. Conjugate-gradient-like band-by-band diagonalization. MUCH slower than 'david' but uses less memory and is (a little bit) more robust. PPCG iterative diagonalization (end support on Dec 2024) ParO iterative diagonalization RMM-DIIS iterative diagonalization. To stabilize the SCF loop RMM-DIIS is alternated with calls to Davidson or ParO solvers depending on the string used. Other variables that can be used to tune the behavior of RMM-DIIS are: diago_rmm_ndim and diago_rmm_conv",
          "options": [
            "'david'",
            "'cg'",
            "'ppcg'",
            "'paro'",
            "'ParO'",
            "'rmm-davidson'",
            "'rmm-paro'"
          ],
          "units": "default",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Available options are: Davidson iterative diagonalization with overlap matrix (default). Fast, may in some rare cases fail. Conjugate-gradient-like band-by-band diagonalization. MUCH slower than 'david' but uses less memory and is (a little bit) more robust. PPCG iterative diagonalization (end support on Dec 2024) ParO iterative diagonalization RMM-DIIS iterative diagonalization. To stabilize the SCF loop RMM-DIIS is alternated with calls to Davidson or ParO solvers depending on the string used. Other variables that can be used to tune the behavior of RMM-DIIS are: diago_rmm_ndim and diago_rmm_conv"
        },
        "diago_thr_init": {
          "name": "diago_thr_init",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": null,
          "description": "Convergence threshold (ethr) for iterative diagonalization (the check is on eigenvalue convergence). For scf calculations: default is 1.D-2 if starting from a superposition of atomic orbitals; 1.D-5 if starting from a charge density. During self consistency the threshold is automatically reduced (but never below 1.D-13) when approaching convergence. For non-scf calculations: default is ( conv_thr /N elec)/10.",
          "options": [],
          "units": "ethr",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Convergence threshold (ethr) for iterative diagonalization (the check is on eigenvalue convergence). For scf calculations: default is 1.D-2 if starting from a superposition of atomic orbitals; 1.D-5 if starting from a charge density. During self consistency the threshold is automatically reduced (but never below 1.D-13) when approaching convergence. For non-scf calculations: default is ( conv_thr /N elec)/10."
        },
        "diago_cg_maxiter": {
          "name": "diago_cg_maxiter",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": null,
          "description": "For conjugate gradient diagonalization: max number of iterations",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "For conjugate gradient diagonalization: max number of iterations"
        },
        "diago_david_ndim": {
          "name": "diago_david_ndim",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "2",
          "description": "For Davidson diagonalization: dimension of workspace (number of wavefunction packets, at least 2 needed). A larger value may yield a smaller number of iterations in the algorithm but uses more memory and more CPU time in subspace diagonalization (cdiaghg/rdiaghg). You may try diago_david_ndim =4 if you are not tight on memory and if the time spent in subspace diagonalization is small compared to the time spent in h_psi",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "For Davidson diagonalization: dimension of workspace (number of wavefunction packets, at least 2 needed). A larger value may yield a smaller number of iterations in the algorithm but uses more memory and more CPU time in subspace diagonalization (cdiaghg/rdiaghg). You may try diago_david_ndim =4 if you are not tight on memory and if the time spent in subspace diagonalization is small compared to the time spent in h_psi"
        },
        "diago_rmm_ndim": {
          "name": "diago_rmm_ndim",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "4",
          "description": "For RMM-DIIS diagonalization: dimension of workspace (number of wavefunction packets, at least 2 needed).",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "For RMM-DIIS diagonalization: dimension of workspace (number of wavefunction packets, at least 2 needed)."
        },
        "diago_rmm_conv": {
          "name": "diago_rmm_conv",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE., RMM-DIIS is performed up to converge. If .FALSE., RMM-DIIS is performed only once.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE., RMM-DIIS is performed up to converge. If .FALSE., RMM-DIIS is performed only once."
        },
        "diago_gs_nblock": {
          "name": "diago_gs_nblock",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "16",
          "description": "For RMM-DIIS diagonalization: blocking size of Gram-Schmidt orthogonalization",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "For RMM-DIIS diagonalization: blocking size of Gram-Schmidt orthogonalization"
        },
        "diago_full_acc": {
          "name": "diago_full_acc",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE. all the empty states are diagonalized at the same level of accuracy of the occupied ones. Otherwise the empty states are diagonalized using a larger threshold (this should not affect total energy, forces, and other ground-state properties).",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE. all the empty states are diagonalized at the same level of accuracy of the occupied ones. Otherwise the empty states are diagonalized using a larger threshold (this should not affect total energy, forces, and other ground-state properties)."
        },
        "efield": {
          "name": "efield",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.D0",
          "description": "Amplitude of the finite electric field (in Ry a.u.; 1 a.u. = 36.3609*10^10 V/m). Used only if lelfield ==.TRUE. and if k-points ( K_POINTS card) are not automatic.",
          "options": [],
          "units": "Ry",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Amplitude of the finite electric field (in Ry a.u.; 1 a.u. = 36.3609*10^10 V/m). Used only if lelfield ==.TRUE. and if k-points ( K_POINTS card) are not automatic."
        },
        "efield_cart(i), i=1,3": {
          "name": "efield_cart(i), i=1,3",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Array",
          "default": "(0.D0, 0.D0, 0.D0)",
          "description": "Finite electric field (in Ry a.u.=36.3609*10^10 V/m) in cartesian axis. Used only if lelfield ==.TRUE. and if k-points ( K_POINTS card) are automatic.",
          "options": [],
          "units": "Ry",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Finite electric field (in Ry a.u.=36.3609*10^10 V/m) in cartesian axis. Used only if lelfield ==.TRUE. and if k-points ( K_POINTS card) are automatic."
        },
        "efield_phase": {
          "name": "efield_phase",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "String",
          "default": "'none'",
          "description": "Available options are: set the zero of the electronic polarization (with lelfield ==.true..) to the result of a previous calculation write on disk data on electronic polarization to be read in another calculation none of the above points",
          "options": [
            "'read'",
            "'write'",
            "'none'"
          ],
          "units": "another",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Available options are: set the zero of the electronic polarization (with lelfield ==.true..) to the result of a previous calculation write on disk data on electronic polarization to be read in another calculation none of the above points"
        },
        "startingpot": {
          "name": "startingpot",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "String",
          "default": null,
          "description": "Available options are: starting potential from atomic charge superposition (default for scf, *relax, *md) start from existing \"charge-density.xml\" file in the directory specified by variables prefix and outdir For nscf and bands calculation this is the default and the only sensible possibility.",
          "options": [
            "'atomic'",
            "'file'"
          ],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Available options are: starting potential from atomic charge superposition (default for scf, *relax, *md) start from existing \"charge-density.xml\" file in the directory specified by variables prefix and outdir For nscf and bands calculation this is the default and the only sensible possibility."
        },
        "startingwfc": {
          "name": "startingwfc",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "String",
          "default": "'atomic+random'",
          "description": "Available options are: Start from superposition of atomic orbitals. If not enough atomic orbitals are available, fill with random numbers the remaining wfcs The scf typically starts better with this option, but in some high-symmetry cases one can \"loose\" valence states, ending up in the wrong ground state. As above, plus a superimposed \"randomization\" of atomic orbitals. Prevents the \"loss\" of states mentioned above. Start from random wfcs. Slower start of scf but safe. It may also reduce memory usage in conjunction with diagonalization ='cg'. Start from an existing wavefunction file in the directory specified by variables prefix and outdir .",
          "options": [
            "'atomic'",
            "'atomic+random'",
            "'random'",
            "'file'",
            "'cg'"
          ],
          "units": "some",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Available options are: Start from superposition of atomic orbitals. If not enough atomic orbitals are available, fill with random numbers the remaining wfcs The scf typically starts better with this option, but in some high-symmetry cases one can \"loose\" valence states, ending up in the wrong ground state. As above, plus a superimposed \"randomization\" of atomic orbitals. Prevents the \"loss\" of states mentioned above. Start from random wfcs. Slower start of scf but safe. It may also reduce memory usage in conjunction with diagonalization ='cg'. Start from an existing wavefunction file in the directory specified by variables prefix and outdir ."
        },
        "tqr": {
          "name": "tqr",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .true., use a real-space algorithm for augmentation charges of ultrasoft pseudopotentials and PAWsets. Faster but numerically less accurate than the default G-space algorithm. Use with care and after testing!",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .true., use a real-space algorithm for augmentation charges of ultrasoft pseudopotentials and PAWsets. Faster but numerically less accurate than the default G-space algorithm. Use with care and after testing!"
        },
        "real_space": {
          "name": "real_space",
          "section": "& ELECTRONS",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .true., exploit real-space localization to compute matrix elements for nonlocal projectors. Faster and in principle better scaling than the default G-space algorithm, but numerically less accurate, may lead to some loss of translational invariance. Use with care and after testing!",
          "options": [],
          "units": "principle",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .true., exploit real-space localization to compute matrix elements for nonlocal projectors. Faster and in principle better scaling than the default G-space algorithm, but numerically less accurate, may lead to some loss of translational invariance. Use with care and after testing!"
        }
      }
    },
    "& IONS": {
      "sectionType": "namelist",
      "variables": {
        "ion_positions": {
          "name": "ion_positions",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "String",
          "default": "'default'",
          "description": "Available options are: if restarting, use atomic positions read from the restart file; in all other cases, use atomic positions from standard input. read atomic positions from standard input, even if restarting.",
          "options": [
            "'default'",
            "'from_input'"
          ],
          "units": "all",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Available options are: if restarting, use atomic positions read from the restart file; in all other cases, use atomic positions from standard input. read atomic positions from standard input, even if restarting."
        },
        "ion_velocities": {
          "name": "ion_velocities",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "String",
          "default": "'default'",
          "description": "Initial ionic velocities. Available options are: start a new simulation from random thermalized distribution of velocities if tempw is set, with zero velocities otherwise; restart from atomic velocities read from the restart file start or continue the simulation with atomic velocities read from standard input - see card ATOMIC_VELOCITIES",
          "options": [
            "'default'",
            "'from_input'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "is == .TRUE."
            ]
          },
          "rawText": "Initial ionic velocities. Available options are: start a new simulation from random thermalized distribution of velocities if tempw is set, with zero velocities otherwise; restart from atomic velocities read from the restart file start or continue the simulation with atomic velocities read from standard input - see card ATOMIC_VELOCITIES"
        },
        "ion_dynamics": {
          "name": "ion_dynamics",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "String",
          "default": null,
          "description": "Specify the type of ionic dynamics. For different type of calculation different possibilities are allowed and different default values apply: CASE ( calculation == 'relax' ) (default) use BFGS quasi-newton algorithm, based on the trust radius procedure, for structural relaxation use damped (quick-min Verlet) dynamics for structural relaxation Can be used for constrained optimisation: see CONSTRAINTS card use the FIRE minimization algorithm employing the semi-implicit Euler integration scheme see: Bitzek et al., PRL, 97, 170201, (2006) , doi: 10.1103/PhysRevLett.97.170201 Guenole et al.,CMS, 175, 109584, (2020), doi: 10.1016/j.commatsci.2020.109584 Can be used for constrained optimisation: see CONSTRAINTS card CASE ( calculation == 'md' ) (default) use Verlet algorithm to integrate Newton's equation. For constrained dynamics, see CONSTRAINTS card use velocity-Verlet algorithm to integrate Newton's equation. For constrained dynamics, see CONSTRAINTS card. ion dynamics is over-damped Langevin over-damped Langevin with Smart Monte Carlo: see R.J. Rossky, JCP, 69, 4628 (1978), doi:10.1063/1.436415 CASE ( calculation == 'vc-relax' ) (default) use BFGS quasi-newton algorithm; cell_dynamics must be 'bfgs' too use damped (Beeman) dynamics for structural relaxation CASE ( calculation == 'vc-md' ) (default) use Beeman algorithm to integrate Newton's equation",
          "options": [
            "'bfgs'",
            "'damp'",
            "'fire'",
            "'verlet'",
            "'velocity-verlet'",
            "'langevin'",
            "'langevin-smc'",
            "'beeman'",
            "'relax'",
            "'md'",
            "'s equation. For constrained dynamics, see CONSTRAINTS card use velocity-Verlet algorithm to integrate Newton'",
            "'vc-relax'",
            "'vc-md'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Specify the type of ionic dynamics. For different type of calculation different possibilities are allowed and different default values apply: CASE ( calculation == 'relax' ) (default) use BFGS quasi-newton algorithm, based on the trust radius procedure, for structural relaxation use damped (quick-min Verlet) dynamics for structural relaxation Can be used for constrained optimisation: see CONSTRAINTS card use the FIRE minimization algorithm employing the semi-implicit Euler integration scheme see: Bitzek et al., PRL, 97, 170201, (2006) , doi: 10.1103/PhysRevLett.97.170201 Guenole et al.,CMS, 175, 109584, (2020), doi: 10.1016/j.commatsci.2020.109584 Can be used for constrained optimisation: see CONSTRAINTS card CASE ( calculation == 'md' ) (default) use Verlet algorithm to integrate Newton's equation. For constrained dynamics, see CONSTRAINTS card use velocity-Verlet algorithm to integrate Newton's equation. For constrained dynamics, see CONSTRAINTS card. ion dynamics is over-damped Langevin over-damped Langevin with Smart Monte Carlo: see R.J. Rossky, JCP, 69, 4628 (1978), doi:10.1063/1.436415 CASE ( calculation == 'vc-relax' ) (default) use BFGS quasi-newton algorithm; cell_dynamics must be 'bfgs' too use damped (Beeman) dynamics for structural relaxation CASE ( calculation == 'vc-md' ) (default) use Beeman algorithm to integrate Newton's equation"
        },
        "pot_extrapolation": {
          "name": "pot_extrapolation",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "String",
          "default": "'atomic'",
          "description": "Used to extrapolate the potential from preceding ionic steps. no extrapolation extrapolate the potential as if it was a sum of atomic-like orbitals extrapolate the potential with first-order formula as above, with second order formula Note: 'first_order' and 'second-order' extrapolation make sense only for molecular dynamics calculations",
          "options": [
            "'none'",
            "'atomic'",
            "'first_order'",
            "'second_order'",
            "'second-order'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Used to extrapolate the potential from preceding ionic steps. no extrapolation extrapolate the potential as if it was a sum of atomic-like orbitals extrapolate the potential with first-order formula as above, with second order formula Note: 'first_order' and 'second-order' extrapolation make sense only for molecular dynamics calculations"
        },
        "wfc_extrapolation": {
          "name": "wfc_extrapolation",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "String",
          "default": "'none'",
          "description": "Used to extrapolate the wavefunctions from preceding ionic steps. no extrapolation extrapolate the wave-functions with first-order formula. as above, with second order formula. Note: 'first_order' and 'second-order' extrapolation make sense only for molecular dynamics calculations",
          "options": [
            "'none'",
            "'first_order'",
            "'second_order'",
            "'second-order'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Used to extrapolate the wavefunctions from preceding ionic steps. no extrapolation extrapolate the wave-functions with first-order formula. as above, with second order formula. Note: 'first_order' and 'second-order' extrapolation make sense only for molecular dynamics calculations"
        },
        "remove_rigid_rot": {
          "name": "remove_rigid_rot",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "This keyword is useful when simulating the dynamics and/or the thermodynamics of an isolated system. If set to true the total torque of the internal forces is set to zero by adding new forces that compensate the spurious interaction with the periodic images. This allows for the use of smaller supercells. BEWARE: since the potential energy is no longer consistent with the forces (it still contains the spurious interaction with the repeated images), the total energy is not conserved anymore. However the dynamical and thermodynamical properties should be in closer agreement with those of an isolated system. Also the final energy of a structural relaxation will be higher, but the relaxation itself should be faster.",
          "options": [],
          "units": "closer",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "is == .TRUE."
            ]
          },
          "rawText": "This keyword is useful when simulating the dynamics and/or the thermodynamics of an isolated system. If set to true the total torque of the internal forces is set to zero by adding new forces that compensate the spurious interaction with the periodic images. This allows for the use of smaller supercells. BEWARE: since the potential energy is no longer consistent with the forces (it still contains the spurious interaction with the repeated images), the total energy is not conserved anymore. However the dynamical and thermodynamical properties should be in closer agreement with those of an isolated system. Also the final energy of a structural relaxation will be higher, but the relaxation itself should be faster."
        },
        "ion_temperature": {
          "name": "ion_temperature",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "String",
          "default": "'not_controlled'",
          "description": "Available options are: control ionic temperature via velocity rescaling (first method) see parameters tempw , tolp , and nraise (for VC-MD only). control ionic temperature via velocity rescaling (second method) see parameters tempw and nraise scale temperature of the thermostat every nraise steps by delta_t , starting from tempw . The temperature is controlled via velocitiy rescaling. reduce temperature of the thermostat every nraise steps by the (negative) value delta_t , starting from tempw . If delta_t is positive, the target temperature is augmented. The temperature is controlled via velocitiy rescaling. control ionic temperature using Nose-Hoover thermostat. See also parameters fnosep , tempw , nhpcl , ndega , nhptyp control ionic temperature using \"soft\" velocity rescaling - see parameters tempw and nraise control ionic temperature using Andersen thermostat see parameters tempw and nraise control ionic temperature using stochastic-velocity rescaling (Donadio, Bussi, Parrinello, J. Chem. Phys. 126, 014101, 2007), with parameters tempw and nraise . initialize ion velocities to temperature tempw and leave uncontrolled further on (default) ionic temperature is not controlled",
          "options": [
            "'rescaling'",
            "'rescale-v'",
            "'rescale-T'",
            "'reduce-T'",
            "'nose'",
            "'berendsen'",
            "'andersen'",
            "'svr'",
            "'initial'",
            "'not_controlled'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Available options are: control ionic temperature via velocity rescaling (first method) see parameters tempw , tolp , and nraise (for VC-MD only). control ionic temperature via velocity rescaling (second method) see parameters tempw and nraise scale temperature of the thermostat every nraise steps by delta_t , starting from tempw . The temperature is controlled via velocitiy rescaling. reduce temperature of the thermostat every nraise steps by the (negative) value delta_t , starting from tempw . If delta_t is positive, the target temperature is augmented. The temperature is controlled via velocitiy rescaling. control ionic temperature using Nose-Hoover thermostat. See also parameters fnosep , tempw , nhpcl , ndega , nhptyp control ionic temperature using \"soft\" velocity rescaling - see parameters tempw and nraise control ionic temperature using Andersen thermostat see parameters tempw and nraise control ionic temperature using stochastic-velocity rescaling (Donadio, Bussi, Parrinello, J. Chem. Phys. 126, 014101, 2007), with parameters tempw and nraise . initialize ion velocities to temperature tempw and leave uncontrolled further on (default) ionic temperature is not controlled"
        },
        "tempw": {
          "name": "tempw",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "300.D0",
          "description": "Starting temperature (Kelvin) in MD runs target temperature for most thermostats.",
          "options": [],
          "units": "K",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Starting temperature (Kelvin) in MD runs target temperature for most thermostats."
        },
        "fnosep": {
          "name": "fnosep",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D0",
          "description": "oscillation frequency of the Nose thermorstat (in THz) [note that 3 THz = 100 cm^-1], meaningful only with \"ion_temperature = 'nose'\" for Nose-Hoover chain one can ser frequncies for all nhpcl thermostats ( fnosep = X Y Z etc.) If only first is set, the defaults for the others will be the same.",
          "options": [
            "'nose'"
          ],
          "units": "THz",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "is == .TRUE."
            ]
          },
          "rawText": "oscillation frequency of the Nose thermorstat (in THz) [note that 3 THz = 100 cm^-1], meaningful only with \"ion_temperature = 'nose'\" for Nose-Hoover chain one can ser frequncies for all nhpcl thermostats ( fnosep = X Y Z etc.) If only first is set, the defaults for the others will be the same."
        },
        "nhpcl": {
          "name": "nhpcl",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "1",
          "description": "number of thermostats in the Nose-Hoover chain; currently maximum allowed is 4",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "number of thermostats in the Nose-Hoover chain; currently maximum allowed is 4"
        },
        "nhptyp": {
          "name": "nhptyp",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "0",
          "description": "type of the \"massive\" Nose-Hoover chain thermostat: * nhptyp = 0 usese one NH chain for all atoms. * nhtyp=1 uses a NH chain per each atomic type * nhptyp=2 use a NH chaing per atom, this one is usefulf for extremely rapid equipartioning. * nhptyp =3 together with nhgrp allows fine grained thermostat control",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "type of the \"massive\" Nose-Hoover chain thermostat: * nhptyp = 0 usese one NH chain for all atoms. * nhtyp=1 uses a NH chain per each atomic type * nhptyp=2 use a NH chaing per atom, this one is usefulf for extremely rapid equipartioning. * nhptyp =3 together with nhgrp allows fine grained thermostat control"
        },
        "nhgrp(i), i=1,ntyp": {
          "name": "nhgrp(i), i=1,ntyp",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Array",
          "default": "0",
          "description": "specifies which thermostat group to use for given atomic type when >0 assigns all the atoms in this type to thermostat labeled nhgrp(i), when =0 each atom in the type gets its own thermostat. Finally, when <0, then this atomic type will have temperature \"not controlled\". Example: HCOOLi, with types H (1), C(2), O(3), Li(4); setting nhgrp={2 2 0 -1} will add a common thermostat for both H & C, one thermostat per each O (2 in total), and a non-updated thermostat for Li which will effectively make temperature for Li \"not controlled\"",
          "options": [],
          "units": "i",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "specifies which thermostat group to use for given atomic type when >0 assigns all the atoms in this type to thermostat labeled nhgrp(i), when =0 each atom in the type gets its own thermostat. Finally, when <0, then this atomic type will have temperature \"not controlled\". Example: HCOOLi, with types H (1), C(2), O(3), Li(4); setting nhgrp={2 2 0 -1} will add a common thermostat for both H & C, one thermostat per each O (2 in total), and a non-updated thermostat for Li which will effectively make temperature for Li \"not controlled\""
        },
        "fnhscl(i), i=1,ntyp": {
          "name": "fnhscl(i), i=1,ntyp",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Array",
          "default": "(Nat_{total}-1)/Nat_{total}",
          "description": "these are the scaling factors to be used together with nhptyp=3 and nhgrp(i) in order to take care of possible reduction in the degrees of freedom due to constraints. Suppose that with the previous example HCOOLi, C-H bond is constrained. Then, these 2 atoms will have 5 degrees of freedom in total instead of 6, and one can set fnhscl={5/6 5/6 1. 1.}. This way the target kinetic energy for H&C will become 6(kT/2)*5/6 = 5(kT/2). This option is to be used for simulations with many constraints, such as rigid water with something else in there",
          "options": [],
          "units": "i",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "these are the scaling factors to be used together with nhptyp=3 and nhgrp(i) in order to take care of possible reduction in the degrees of freedom due to constraints. Suppose that with the previous example HCOOLi, C-H bond is constrained. Then, these 2 atoms will have 5 degrees of freedom in total instead of 6, and one can set fnhscl={5/6 5/6 1. 1.}. This way the target kinetic energy for H&C will become 6(kT/2)*5/6 = 5(kT/2). This option is to be used for simulations with many constraints, such as rigid water with something else in there"
        },
        "ndega": {
          "name": "ndega",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "0",
          "description": "number of degrees of freedom used for temperature calculation ndega <= 0 sets the number of degrees of freedom to [3*nat-abs(ndega)], ndega > 0 is used as the target number",
          "options": [],
          "units": "ndega",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "number of degrees of freedom used for temperature calculation ndega <= 0 sets the number of degrees of freedom to [3*nat-abs(ndega)], ndega > 0 is used as the target number"
        },
        "tolp": {
          "name": "tolp",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "100.D0",
          "description": "Tolerance for velocity rescaling. Velocities are rescaled if the run-averaged and target temperature differ more than tolp.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Tolerance for velocity rescaling. Velocities are rescaled if the run-averaged and target temperature differ more than tolp."
        },
        "delta_t": {
          "name": "delta_t",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D0",
          "description": "if ion_temperature == 'rescale-T' : at each step the instantaneous temperature is multiplied by delta_t; this is done rescaling all the velocities. if ion_temperature == 'reduce-T' : every 'nraise' steps the instantaneous temperature is reduced by - delta_t (i.e. delta_t < 0 is added to T) The instantaneous temperature is calculated at the end of every ionic move and BEFORE rescaling. This is the temperature reported in the main output. For delta_t < 0, the actual average rate of heating or cooling should be roughly C*delta_t/(nraise*dt) (C=1 for an ideal gas, C=0.5 for a harmonic solid, theorem of energy equipartition between all quadratic degrees of freedom).",
          "options": [
            "'rescale-T'",
            "'reduce-T'",
            "'nraise'"
          ],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "ion_temperature == 'rescale-T'",
              "ion_temperature == 'reduce-T'"
            ]
          },
          "rawText": "if ion_temperature == 'rescale-T' : at each step the instantaneous temperature is multiplied by delta_t; this is done rescaling all the velocities. if ion_temperature == 'reduce-T' : every 'nraise' steps the instantaneous temperature is reduced by - delta_t (i.e. delta_t < 0 is added to T) The instantaneous temperature is calculated at the end of every ionic move and BEFORE rescaling. This is the temperature reported in the main output. For delta_t < 0, the actual average rate of heating or cooling should be roughly C*delta_t/(nraise*dt) (C=1 for an ideal gas, C=0.5 for a harmonic solid, theorem of energy equipartition between all quadratic degrees of freedom)."
        },
        "nraise": {
          "name": "nraise",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "1",
          "description": "if ion_temperature == 'reduce-T' : every nraise steps the instantaneous temperature is reduced by - delta_t (i.e. delta_t is added to the temperature) if ion_temperature == 'rescale-v' : every nraise steps the average temperature, computed from the last nraise steps, is rescaled to tempw if ion_temperature == 'rescaling' and calculation == 'vc-md' : every nraise steps the instantaneous temperature is rescaled to tempw if ion_temperature == 'berendsen' : the \"rise time\" parameter is given in units of the time step: tau = nraise*dt, so dt/tau = 1/nraise if ion_temperature == 'andersen' : the \"collision frequency\" parameter is given as nu=1/tau defined above, so nu*dt = 1/nraise if ion_temperature == 'svr' : the \"characteristic time\" of the thermostat is set to tau = nraise*dt",
          "options": [
            "'reduce-T'",
            "'rescale-v'",
            "'rescaling'",
            "'vc-md'",
            "'berendsen'",
            "'andersen'",
            "'svr'"
          ],
          "units": "units",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "ion_temperature == 'reduce-T'",
              "ion_temperature == 'rescale-v'"
            ]
          },
          "rawText": "if ion_temperature == 'reduce-T' : every nraise steps the instantaneous temperature is reduced by - delta_t (i.e. delta_t is added to the temperature) if ion_temperature == 'rescale-v' : every nraise steps the average temperature, computed from the last nraise steps, is rescaled to tempw if ion_temperature == 'rescaling' and calculation == 'vc-md' : every nraise steps the instantaneous temperature is rescaled to tempw if ion_temperature == 'berendsen' : the \"rise time\" parameter is given in units of the time step: tau = nraise*dt, so dt/tau = 1/nraise if ion_temperature == 'andersen' : the \"collision frequency\" parameter is given as nu=1/tau defined above, so nu*dt = 1/nraise if ion_temperature == 'svr' : the \"characteristic time\" of the thermostat is set to tau = nraise*dt"
        },
        "refold_pos": {
          "name": "refold_pos",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "This keyword applies only in the case of molecular dynamics or damped dynamics. If true the ions are refolded at each step into the supercell.",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "This keyword applies only in the case of molecular dynamics or damped dynamics. If true the ions are refolded at each step into the supercell."
        },
        "upscale": {
          "name": "upscale",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "100.D0",
          "description": "Max reduction factor for conv_thr during structural optimization conv_thr is automatically reduced when the relaxation approaches convergence so that forces are still accurate, but conv_thr will not be reduced to less that conv_thr / upscale .",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Max reduction factor for conv_thr during structural optimization conv_thr is automatically reduced when the relaxation approaches convergence so that forces are still accurate, but conv_thr will not be reduced to less that conv_thr / upscale ."
        },
        "bfgs_ndim": {
          "name": "bfgs_ndim",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "1",
          "description": "Number of old forces and displacements vectors used in the PULAY (GDIIS) mixing of the residual vectors obtained on the basis of the inverse hessian matrix given by the BFGS algorithm. The variable tgdiis_step in this case sets whether to use to full GDIIS step or the BFGS trust_radius. When bfgs_ndim = 1, the standard quasi-Newton BFGS method is used. (bfgs only)",
          "options": [],
          "units": "GDIIS",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Number of old forces and displacements vectors used in the PULAY (GDIIS) mixing of the residual vectors obtained on the basis of the inverse hessian matrix given by the BFGS algorithm. The variable tgdiis_step in this case sets whether to use to full GDIIS step or the BFGS trust_radius. When bfgs_ndim = 1, the standard quasi-Newton BFGS method is used. (bfgs only)"
        },
        "tgdiis_step": {
          "name": "tgdiis_step",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".true.",
          "description": "When G-DIIS ( bfgs_ndim > 1) is used for the structural relaxation this variable selects whether to use to full gdiis step or the BFGS trus radius. (bfgs only)",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "When G-DIIS ( bfgs_ndim > 1) is used for the structural relaxation this variable selects whether to use to full gdiis step or the BFGS trus radius. (bfgs only)"
        },
        "trust_radius_max": {
          "name": "trust_radius_max",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.8D0",
          "description": "Maximum ionic displacement in the structural relaxation. (bfgs only)",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Maximum ionic displacement in the structural relaxation. (bfgs only)"
        },
        "trust_radius_min": {
          "name": "trust_radius_min",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D-3",
          "description": "Minimum ionic displacement in the structural relaxation BFGS is reset when trust_radius < trust_radius_min . (bfgs only)",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Minimum ionic displacement in the structural relaxation BFGS is reset when trust_radius < trust_radius_min . (bfgs only)"
        },
        "trust_radius_ini": {
          "name": "trust_radius_ini",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.5D0",
          "description": "Initial ionic displacement in the structural relaxation. (bfgs only)",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Initial ionic displacement in the structural relaxation. (bfgs only)"
        },
        "w_1": {
          "name": "w_1",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.01D0",
          "description": null,
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": null
        },
        "w_2": {
          "name": "w_2",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.5D0",
          "description": "Parameters used in line search based on the Wolfe conditions. (bfgs only)",
          "options": [],
          "units": "line",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Parameters used in line search based on the Wolfe conditions. (bfgs only)"
        },
        "fire_alpha_init": {
          "name": "fire_alpha_init",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.2D0",
          "description": "Initial value of the alpha mixing factor in the FIRE minimization scheme; recommended values are between 0.1 and 0.3",
          "options": [],
          "units": "the",
          "range": "0.1..0.3",
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Initial value of the alpha mixing factor in the FIRE minimization scheme; recommended values are between 0.1 and 0.3"
        },
        "fire_falpha": {
          "name": "fire_falpha",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.99D0",
          "description": "Scaling of the alpha mixing parameter for steps with P > 0;",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Scaling of the alpha mixing parameter for steps with P > 0;"
        },
        "fire_nmin": {
          "name": "fire_nmin",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "5",
          "description": "Minimum number of steps with P > 0 before increase of dt",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Minimum number of steps with P > 0 before increase of dt"
        },
        "fire_f_inc": {
          "name": "fire_f_inc",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.1D0",
          "description": "Factor for increasing dt",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Factor for increasing dt"
        },
        "fire_f_dec": {
          "name": "fire_f_dec",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.5D0",
          "description": "Factor for decreasing dt",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Factor for decreasing dt"
        },
        "fire_dtmax": {
          "name": "fire_dtmax",
          "section": "& IONS",
          "sectionType": "namelist",
          "type": "Real",
          "default": "10.D0",
          "description": "Determines the maximum value of dt in the FIRE minimization; dtmax = fire_dtmax* dt",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Determines the maximum value of dt in the FIRE minimization; dtmax = fire_dtmax* dt"
        }
      }
    },
    "& CELL": {
      "sectionType": "namelist",
      "variables": {
        "cell_dynamics": {
          "name": "cell_dynamics",
          "section": "& CELL",
          "sectionType": "namelist",
          "type": "String",
          "default": null,
          "description": "Specify the type of dynamics for the cell. For different type of calculation different possibilities are allowed and different default values apply: CASE ( calculation == 'vc-relax' ) no dynamics steepest descent ( not implemented ) damped (Beeman) dynamics of the Parrinello-Rahman extended lagrangian damped (Beeman) dynamics of the new Wentzcovitch extended lagrangian BFGS quasi-newton algorithm (default) ion_dynamics must be 'bfgs' too CASE ( calculation == 'vc-md' ) no dynamics (Beeman) molecular dynamics of the Parrinello-Rahman extended lagrangian (Beeman) molecular dynamics of the new Wentzcovitch extended lagrangian",
          "options": [
            "'none'",
            "'sd'",
            "'damp-pr'",
            "'damp-w'",
            "'bfgs'",
            "'pr'",
            "'w'",
            "'vc-relax'",
            "'vc-md'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Specify the type of dynamics for the cell. For different type of calculation different possibilities are allowed and different default values apply: CASE ( calculation == 'vc-relax' ) no dynamics steepest descent ( not implemented ) damped (Beeman) dynamics of the Parrinello-Rahman extended lagrangian damped (Beeman) dynamics of the new Wentzcovitch extended lagrangian BFGS quasi-newton algorithm (default) ion_dynamics must be 'bfgs' too CASE ( calculation == 'vc-md' ) no dynamics (Beeman) molecular dynamics of the Parrinello-Rahman extended lagrangian (Beeman) molecular dynamics of the new Wentzcovitch extended lagrangian"
        },
        "press": {
          "name": "press",
          "section": "& CELL",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.D0",
          "description": "Target pressure [KBar] in a variable-cell md or relaxation run.",
          "options": [],
          "units": "a",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Target pressure [KBar] in a variable-cell md or relaxation run."
        },
        "wmass": {
          "name": "wmass",
          "section": "& CELL",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.75*Tot_Mass/pi**2 for Parrinello-Rahman MD; 0.75*Tot_Mass/pi**2/Omega**(2/3) for Wentzcovitch MD",
          "description": "Fictitious cell mass [amu] for variable-cell simulations (both 'vc-md' and 'vc-relax')",
          "options": [
            "'vc-md'",
            "'vc-relax'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Fictitious cell mass [amu] for variable-cell simulations (both 'vc-md' and 'vc-relax')"
        },
        "cell_factor": {
          "name": "cell_factor",
          "section": "& CELL",
          "sectionType": "namelist",
          "type": "Real",
          "default": "2.0 for variable-cell calculations, 1.0 otherwise",
          "description": "Used in the construction of the pseudopotential tables. It should exceed the maximum linear contraction of the cell during a simulation.",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Used in the construction of the pseudopotential tables. It should exceed the maximum linear contraction of the cell during a simulation."
        },
        "press_conv_thr": {
          "name": "press_conv_thr",
          "section": "& CELL",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.5D0 Kbar",
          "description": "Convergence threshold on the pressure for variable cell relaxation ('vc-relax' : note that the other convergence thresholds for ionic relaxation apply as well).",
          "options": [
            "'vc-relax'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Convergence threshold on the pressure for variable cell relaxation ('vc-relax' : note that the other convergence thresholds for ionic relaxation apply as well)."
        },
        "cell_dofree": {
          "name": "cell_dofree",
          "section": "& CELL",
          "sectionType": "namelist",
          "type": "String",
          "default": "'all'",
          "description": "Select which of the cell parameters should be moved: all axis and angles are moved all axis and angles are moved, but the lattice remains consistent with the initial ibrav choice. You can use this option in combination with any other one by specifying \"ibrav+option\". Please note that some combinations do not make sense for some crystals and will guarantee that the relax will never converge. E.g. 'ibrav+2Dxy' is not a problem for hexagonal cells, but will never converge for cubic ones. the x component of axis 1 (v1_x) is fixed the y component of axis 2 (v2_y) is fixed the z component of axis 3 (v3_z) is fixed axis 1 (v1_x,v1_y,v1_z) is fixed axis 2 (v2_x,v2_y,v2_z) is fixed axis 3 (v3_x,v3_y,v3_z) is fixed only the x component of axis 1 (v1_x) is moved only the y component of axis 2 (v2_y) is moved only the z component of axis 3 (v3_z) is moved only v1_x and v2_y are moved only v1_x and v3_z are moved only v2_y and v3_z are moved only v1_x, v2_y, v3_z are moved all axis and angles, keeping the volume fixed the volume changes, keeping all angles fixed (i.e. only celldm(1) changes) only x and y components are allowed to change as above, keeping the area in xy plane fixed fix axis 1 and 2 while allowing axis 3 to move fix axis 1 and 3 while allowing axis 2 to move fix axis 2 and 3 while allowing axis 1 to move BEWARE: if axis are not orthogonal, some of these options do not work (symmetry is broken). If you are not happy with them, edit subroutine init_dofree in file Modules/cell_base.f90",
          "options": [
            "'all'",
            "'ibrav'",
            "'a'",
            "'b'",
            "'c'",
            "'fixa'",
            "'fixb'",
            "'fixc'",
            "'x'",
            "'y'",
            "'z'",
            "'xy'",
            "'xz'",
            "'yz'",
            "'xyz'",
            "'shape'",
            "'volume'",
            "'2Dxy'",
            "'2Dshape'",
            "'epitaxial_ab'",
            "'epitaxial_ac'",
            "'epitaxial_bc'",
            "'ibrav+2Dxy'"
          ],
          "units": "combination",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Select which of the cell parameters should be moved: all axis and angles are moved all axis and angles are moved, but the lattice remains consistent with the initial ibrav choice. You can use this option in combination with any other one by specifying \"ibrav+option\". Please note that some combinations do not make sense for some crystals and will guarantee that the relax will never converge. E.g. 'ibrav+2Dxy' is not a problem for hexagonal cells, but will never converge for cubic ones. the x component of axis 1 (v1_x) is fixed the y component of axis 2 (v2_y) is fixed the z component of axis 3 (v3_z) is fixed axis 1 (v1_x,v1_y,v1_z) is fixed axis 2 (v2_x,v2_y,v2_z) is fixed axis 3 (v3_x,v3_y,v3_z) is fixed only the x component of axis 1 (v1_x) is moved only the y component of axis 2 (v2_y) is moved only the z component of axis 3 (v3_z) is moved only v1_x and v2_y are moved only v1_x and v3_z are moved only v2_y and v3_z are moved only v1_x, v2_y, v3_z are moved all axis and angles, keeping the volume fixed the volume changes, keeping all angles fixed (i.e. only celldm(1) changes) only x and y components are allowed to change as above, keeping the area in xy plane fixed fix axis 1 and 2 while allowing axis 3 to move fix axis 1 and 3 while allowing axis 2 to move fix axis 2 and 3 while allowing axis 1 to move BEWARE: if axis are not orthogonal, some of these options do not work (symmetry is broken). If you are not happy with them, edit subroutine init_dofree in file Modules/cell_base.f90"
        }
      }
    },
    "& FCP": {
      "sectionType": "namelist",
      "variables": {
        "fcp_mu": {
          "name": "fcp_mu",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "Real",
          "default": null,
          "description": "The target Fermi energy (eV). One can start with appropriate total charge of the system by giving tot_charge .",
          "options": [],
          "units": "eV",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The target Fermi energy (eV). One can start with appropriate total charge of the system by giving tot_charge ."
        },
        "fcp_dynamics": {
          "name": "fcp_dynamics",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "String",
          "default": null,
          "description": "Specify the type of dynamics for the Fictitious Charge Particle (FCP). For different type of calculation different possibilities are allowed and different default values apply: CASE ( calculation == 'relax' ) (default) BFGS quasi-newton algorithm, coupling with ions relaxation ion_dynamics must be 'bfgs' too Newton-Raphson algorithm with DIIS ion_dynamics must be 'damp' too damped (quick-min Verlet) dynamics for FCP relaxation ion_dynamics must be 'damp' too Line-Minimization algorithm for FCP relaxation ion_dynamics must be 'damp' too CASE ( calculation == 'md' ) (default) Velocity-Verlet algorithm to integrate Newton's equation. ion_dynamics must be 'verlet' too Verlet algorithm to integrate Newton's equation. ion_dynamics must be 'verlet' too",
          "options": [
            "'bfgs'",
            "'newton'",
            "'damp'",
            "'lm'",
            "'velocity-verlet'",
            "'verlet'",
            "'relax'",
            "'md'",
            "'s equation. ion_dynamics must be '",
            "' too Verlet algorithm to integrate Newton'"
          ],
          "units": "FCP",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Specify the type of dynamics for the Fictitious Charge Particle (FCP). For different type of calculation different possibilities are allowed and different default values apply: CASE ( calculation == 'relax' ) (default) BFGS quasi-newton algorithm, coupling with ions relaxation ion_dynamics must be 'bfgs' too Newton-Raphson algorithm with DIIS ion_dynamics must be 'damp' too damped (quick-min Verlet) dynamics for FCP relaxation ion_dynamics must be 'damp' too Line-Minimization algorithm for FCP relaxation ion_dynamics must be 'damp' too CASE ( calculation == 'md' ) (default) Velocity-Verlet algorithm to integrate Newton's equation. ion_dynamics must be 'verlet' too Verlet algorithm to integrate Newton's equation. ion_dynamics must be 'verlet' too"
        },
        "fcp_conv_thr": {
          "name": "fcp_conv_thr",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D-2",
          "description": "Convergence threshold on force (eV) for FCP relaxation.",
          "options": [],
          "units": "eV",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Convergence threshold on force (eV) for FCP relaxation."
        },
        "fcp_ndiis": {
          "name": "fcp_ndiis",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "4",
          "description": "Size of DIIS for FCP relaxation, used only if fcp_dynamics = 'newton'.",
          "options": [
            "'newton'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "fcp_dynamics = 'newton'"
            ]
          },
          "rawText": "Size of DIIS for FCP relaxation, used only if fcp_dynamics = 'newton'."
        },
        "fcp_mass": {
          "name": "fcp_mass",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "Real",
          "default": "5.D+6 / (xy area) for ESM only; 5.D+4 / (xy area) for ESM-RISM",
          "description": "Mass of the FCP.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Mass of the FCP."
        },
        "fcp_velocity": {
          "name": "fcp_velocity",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "Real",
          "default": "determined by fcp_temperature",
          "description": "Initial velocity of the FCP.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Initial velocity of the FCP."
        },
        "fcp_temperature": {
          "name": "fcp_temperature",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "String",
          "default": "ion_temperature",
          "description": "Available options are: control FCP's temperature via velocity rescaling (first method) see parameters fpc_tempw and fcp_tolp . control FCP's temperature via velocity rescaling (second method) see parameters fcp_tempw and fcp_nraise control FCP's temperature via velocity rescaling (third method) see parameter fcp_delta_t reduce FCP's temperature every fcp_nraise steps by the (negative) value fcp_delta_t control FCP's temperature using \"soft\" velocity rescaling - see parameters fcp_tempw and fcp_nraise control FCP's temperature using Andersen thermostat see parameters fcp_tempw and fcp_nraise initialize FCP's velocities to temperature fcp_tempw and leave uncontrolled further on (default) FCP's temperature is not controlled",
          "options": [
            "'rescaling'",
            "'rescale-v'",
            "'rescale-T'",
            "'reduce-T'",
            "'berendsen'",
            "'andersen'",
            "'initial'",
            "'not_controlled'",
            "'s temperature via velocity rescaling (first method) see parameters fpc_tempw and fcp_tolp . control FCP'",
            "'s temperature via velocity rescaling (third method) see parameter fcp_delta_t reduce FCP'",
            "'s temperature using \"soft\" velocity rescaling - see parameters fcp_tempw and fcp_nraise control FCP'",
            "'s velocities to temperature fcp_tempw and leave uncontrolled further on (default) FCP'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Available options are: control FCP's temperature via velocity rescaling (first method) see parameters fpc_tempw and fcp_tolp . control FCP's temperature via velocity rescaling (second method) see parameters fcp_tempw and fcp_nraise control FCP's temperature via velocity rescaling (third method) see parameter fcp_delta_t reduce FCP's temperature every fcp_nraise steps by the (negative) value fcp_delta_t control FCP's temperature using \"soft\" velocity rescaling - see parameters fcp_tempw and fcp_nraise control FCP's temperature using Andersen thermostat see parameters fcp_tempw and fcp_nraise initialize FCP's velocities to temperature fcp_tempw and leave uncontrolled further on (default) FCP's temperature is not controlled"
        },
        "fcp_tempw": {
          "name": "fcp_tempw",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "Real",
          "default": "tempw",
          "description": "Starting temperature (Kelvin) in FCP dynamics runs target temperature for most thermostats.",
          "options": [],
          "units": "K",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Starting temperature (Kelvin) in FCP dynamics runs target temperature for most thermostats."
        },
        "fcp_tolp": {
          "name": "fcp_tolp",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "Real",
          "default": "tolp",
          "description": "Tolerance for velocity rescaling. Velocities are rescaled if the run-averaged and target temperature differ more than tolp.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Tolerance for velocity rescaling. Velocities are rescaled if the run-averaged and target temperature differ more than tolp."
        },
        "fcp_delta_t": {
          "name": "fcp_delta_t",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "Real",
          "default": "delta_t",
          "description": "if fcp_temperature == 'rescale-T' : at each step the instantaneous temperature is multiplied by fcp_delta_t; this is done rescaling all the velocities. if fcp_temperature == 'reduce-T' : every fcp_nraise steps the instantaneous temperature is reduced by - fcp_delta_t (i.e. fcp_delta_t < 0 is added to T) The instantaneous temperature is calculated at the end of FCP's move and BEFORE rescaling. This is the temperature reported in the main output. For fcp_delta_t < 0, the actual average rate of heating or cooling should be roughly C*fcp_delta_t/(fcp_nraise*dt) (C=1 for an ideal gas, C=0.5 for a harmonic solid, theorem of energy equipartition between all quadratic degrees of freedom).",
          "options": [
            "'rescale-T'",
            "'reduce-T'"
          ],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "fcp_temperature == 'rescale-T'",
              "fcp_temperature == 'reduce-T'"
            ]
          },
          "rawText": "if fcp_temperature == 'rescale-T' : at each step the instantaneous temperature is multiplied by fcp_delta_t; this is done rescaling all the velocities. if fcp_temperature == 'reduce-T' : every fcp_nraise steps the instantaneous temperature is reduced by - fcp_delta_t (i.e. fcp_delta_t < 0 is added to T) The instantaneous temperature is calculated at the end of FCP's move and BEFORE rescaling. This is the temperature reported in the main output. For fcp_delta_t < 0, the actual average rate of heating or cooling should be roughly C*fcp_delta_t/(fcp_nraise*dt) (C=1 for an ideal gas, C=0.5 for a harmonic solid, theorem of energy equipartition between all quadratic degrees of freedom)."
        },
        "fcp_nraise": {
          "name": "fcp_nraise",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "nraise",
          "description": "if fcp_temperature == 'reduce-T' : every fcp_nraise steps the instantaneous temperature is reduced by - fcp_delta_t (i.e. fcp_delta_t is added to the temperature) if fcp_temperature == 'rescale-v' : every fcp_nraise steps the average temperature, computed from the last fcp_nraise steps, is rescaled to fcp_tempw if fcp_temperature == 'berendsen' : the \"rise time\" parameter is given in units of the time step: tau = fcp_nraise*dt, so dt/tau = 1/fcp_nraise if fcp_temperature == 'andersen' : the \"collision frequency\" parameter is given as nu=1/tau defined above, so nu*dt = 1/fcp_nraise",
          "options": [
            "'reduce-T'",
            "'rescale-v'",
            "'berendsen'",
            "'andersen'"
          ],
          "units": "units",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "fcp_temperature == 'reduce-T'",
              "fcp_temperature == 'rescale-v'"
            ]
          },
          "rawText": "if fcp_temperature == 'reduce-T' : every fcp_nraise steps the instantaneous temperature is reduced by - fcp_delta_t (i.e. fcp_delta_t is added to the temperature) if fcp_temperature == 'rescale-v' : every fcp_nraise steps the average temperature, computed from the last fcp_nraise steps, is rescaled to fcp_tempw if fcp_temperature == 'berendsen' : the \"rise time\" parameter is given in units of the time step: tau = fcp_nraise*dt, so dt/tau = 1/fcp_nraise if fcp_temperature == 'andersen' : the \"collision frequency\" parameter is given as nu=1/tau defined above, so nu*dt = 1/fcp_nraise"
        },
        "freeze_all_atoms": {
          "name": "freeze_all_atoms",
          "section": "& FCP",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE., freeze all atoms to perform relaxation or dynamics only with FCP.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE., freeze all atoms to perform relaxation or dynamics only with FCP."
        }
      }
    },
    "& RISM": {
      "sectionType": "namelist",
      "variables": {
        "nsolv": {
          "name": "nsolv",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": null,
          "description": "The number of solvents (i.e. molecular species) in the unit cell",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The number of solvents (i.e. molecular species) in the unit cell"
        },
        "closure": {
          "name": "closure",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "String",
          "default": "'kh'",
          "description": "Specify the type of closure equation: The Kovalenko and Hirata's model. [A.Kovalenko, F.Hirata, JCP 110, 10095 (1999), doi:10.1063/1.478883 ] The HyperNetted-Chain model, which is suitable only for solvents without charge. [J.P.Hansen et al., Theory of simple liquids. Academic Press, London, 1990]",
          "options": [
            "'kh'",
            "'hnc'"
          ],
          "units": "1999",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Specify the type of closure equation: The Kovalenko and Hirata's model. [A.Kovalenko, F.Hirata, JCP 110, 10095 (1999), doi:10.1063/1.478883 ] The HyperNetted-Chain model, which is suitable only for solvents without charge. [J.P.Hansen et al., Theory of simple liquids. Academic Press, London, 1990]"
        },
        "tempv": {
          "name": "tempv",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "300.D0",
          "description": "Temperature (Kelvin) of solvents.",
          "options": [],
          "units": "K",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Temperature (Kelvin) of solvents."
        },
        "ecutsolv": {
          "name": "ecutsolv",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "4 * ecutwfc",
          "description": "Kinetic energy cutoff (Ry) for solvent's correlation functions. If a solute is an isolated system or slab, you may allowed to use default value. For a frameworked or porous solute (e.g. Zeolite, MOF), it is desirable to apply a larger value. Solvents confined in a framework often have a high frequency.",
          "options": [],
          "units": "Ry",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Kinetic energy cutoff (Ry) for solvent's correlation functions. If a solute is an isolated system or slab, you may allowed to use default value. For a frameworked or porous solute (e.g. Zeolite, MOF), it is desirable to apply a larger value. Solvents confined in a framework often have a high frequency."
        },
        "solute_lj(i), i=1,ntyp": {
          "name": "solute_lj(i), i=1,ntyp",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Array",
          "default": "'uff'",
          "description": "Specify the Lennard-Jones potential of solute on atomic type 'i': The Lennard-Jones potential is not specified here. you must set solute_epsilon and solute_sigma . Universal Force Field. [A.K.Rappe et al., JACS 144, 10024 (1992), doi:10.1021/ja00051a040 ] Clay's Force Field [R.T.Cygan et al., JPC B 108, 1255 (2004), doi:10.1021/jp0363287 ] OPLS-AA (generic parameters for QM/MM)",
          "options": [
            "'none'",
            "'uff'",
            "'clayff'",
            "'opls-aa'",
            "'i'"
          ],
          "units": "1992",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Specify the Lennard-Jones potential of solute on atomic type 'i': The Lennard-Jones potential is not specified here. you must set solute_epsilon and solute_sigma . Universal Force Field. [A.K.Rappe et al., JACS 144, 10024 (1992), doi:10.1021/ja00051a040 ] Clay's Force Field [R.T.Cygan et al., JPC B 108, 1255 (2004), doi:10.1021/jp0363287 ] OPLS-AA (generic parameters for QM/MM)"
        },
        "solute_epsilon(i), i=1,ntyp": {
          "name": "solute_epsilon(i), i=1,ntyp",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Array",
          "default": null,
          "description": "The Lennard-Jones potential of solute on atomic type 'i'. Here, you can set the parameter 'epsilon' (kcal/mol).",
          "options": [
            "'i'",
            "'epsilon'"
          ],
          "units": "kcal/mol",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The Lennard-Jones potential of solute on atomic type 'i'. Here, you can set the parameter 'epsilon' (kcal/mol)."
        },
        "solute_sigma(i), i=1,ntyp": {
          "name": "solute_sigma(i), i=1,ntyp",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Array",
          "default": null,
          "description": "The Lennard-Jones potential of solute on atomic type 'i'. Here, you can set the parameter 'sigma' (Angstrom).",
          "options": [
            "'i'",
            "'sigma'"
          ],
          "units": "angstrom",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The Lennard-Jones potential of solute on atomic type 'i'. Here, you can set the parameter 'sigma' (Angstrom)."
        },
        "starting1d": {
          "name": "starting1d",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "String",
          "default": null,
          "description": "Starting correlation functions of 1D-RISM from zero. ( default for scf, *relax, *md ) Start from existing \"1d-rism_csvv_r.xml\" file in the directory specified by variables \"prefix\" and \"outdir\". Read from existing \"1d-rism_csvv_r.xml\" file in the directory specified by variables \"prefix\" and \"outdir\", and never calculate 1D-RISM. For nscf and bands calculation this is the default.",
          "options": [
            "'zero'",
            "'file'",
            "'fix'"
          ],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Starting correlation functions of 1D-RISM from zero. ( default for scf, *relax, *md ) Start from existing \"1d-rism_csvv_r.xml\" file in the directory specified by variables \"prefix\" and \"outdir\". Read from existing \"1d-rism_csvv_r.xml\" file in the directory specified by variables \"prefix\" and \"outdir\", and never calculate 1D-RISM. For nscf and bands calculation this is the default."
        },
        "starting3d": {
          "name": "starting3d",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "String",
          "default": null,
          "description": "Starting correlation functions of 3D-RISM from zero. ( default for scf, *relax, *md ) Start from existing \"3d-rism_csuv_r.dat\" file in the directory specified by variables \"prefix\" and \"outdir\". For nscf and bands calculation this is the default.",
          "options": [
            "'zero'",
            "'file'"
          ],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Starting correlation functions of 3D-RISM from zero. ( default for scf, *relax, *md ) Start from existing \"3d-rism_csuv_r.dat\" file in the directory specified by variables \"prefix\" and \"outdir\". For nscf and bands calculation this is the default."
        },
        "smear1d": {
          "name": "smear1d",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "2.D0",
          "description": "Coulomb smearing radius (a.u.) for 1D-RISM.",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Coulomb smearing radius (a.u.) for 1D-RISM."
        },
        "smear3d": {
          "name": "smear3d",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "2.D0",
          "description": "Coulomb smearing radius (a.u.) for 3D-RISM.",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Coulomb smearing radius (a.u.) for 3D-RISM."
        },
        "rism1d_maxstep": {
          "name": "rism1d_maxstep",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "50000",
          "description": "Maximum number of iterations in a 1D-RISM step.",
          "options": [],
          "units": "a",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Maximum number of iterations in a 1D-RISM step."
        },
        "rism3d_maxstep": {
          "name": "rism3d_maxstep",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "5000",
          "description": "Maximum number of iterations in a 3D-RISM step.",
          "options": [],
          "units": "a",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Maximum number of iterations in a 3D-RISM step."
        },
        "rism1d_conv_thr": {
          "name": "rism1d_conv_thr",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D-8",
          "description": "Convergence threshold for 1D-RISM.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Convergence threshold for 1D-RISM."
        },
        "rism3d_conv_thr": {
          "name": "rism3d_conv_thr",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "1.D-5 if lgcscf == .FALSE.; 5.D-6 if lgcscf == .TRUE.",
          "description": "Convergence threshold for 3D-RISM.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Convergence threshold for 3D-RISM."
        },
        "mdiis1d_size": {
          "name": "mdiis1d_size",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "20",
          "description": "Size of Modified DIIS (MDIIS) for 1D-RISM.",
          "options": [],
          "units": "MDIIS",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Size of Modified DIIS (MDIIS) for 1D-RISM."
        },
        "mdiis3d_size": {
          "name": "mdiis3d_size",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "10",
          "description": "Size of Modified DIIS (MDIIS) for 3D-RISM.",
          "options": [],
          "units": "MDIIS",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Size of Modified DIIS (MDIIS) for 3D-RISM."
        },
        "mdiis1d_step": {
          "name": "mdiis1d_step",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.5D0",
          "description": "Step of Modified DIIS (MDIIS) for 1D-RISM.",
          "options": [],
          "units": "MDIIS",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Step of Modified DIIS (MDIIS) for 1D-RISM."
        },
        "mdiis3d_step": {
          "name": "mdiis3d_step",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.8D0",
          "description": "Step of Modified DIIS (MDIIS) for 3D-RISM.",
          "options": [],
          "units": "MDIIS",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Step of Modified DIIS (MDIIS) for 3D-RISM."
        },
        "rism1d_bond_width": {
          "name": "rism1d_bond_width",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": null,
          "description": "Gaussian width of bonds to smear intra-molecular correlation for 1D-RISM. If 3D-RISM calculation, default is 0. If Laue-RISM calculation, default is 2 / SQRT( ecutwfc ).",
          "options": [],
          "units": "ecutwfc",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Gaussian width of bonds to smear intra-molecular correlation for 1D-RISM. If 3D-RISM calculation, default is 0. If Laue-RISM calculation, default is 2 / SQRT( ecutwfc )."
        },
        "rism1d_dielectric": {
          "name": "rism1d_dielectric",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "-1.0D0",
          "description": "Dielectric constant for 1D-RISM. If rism1d_dielectric > 0, dielectrically consistent RISM (DRISM) is performed. For details of DRISM, see: J.S.Perkyns and B.M.Pettitt, CPL 1992, 190, 626, doi:10.1016/0009-2614(92)85201-K",
          "options": [],
          "units": "DRISM",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "rism1d_dielectric > 0"
            ]
          },
          "rawText": "Dielectric constant for 1D-RISM. If rism1d_dielectric > 0, dielectrically consistent RISM (DRISM) is performed. For details of DRISM, see: J.S.Perkyns and B.M.Pettitt, CPL 1992, 190, 626, doi:10.1016/0009-2614(92)85201-K"
        },
        "rism1d_molesize": {
          "name": "rism1d_molesize",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "2.0D0",
          "description": "Size of solvent molecules (a.u.) for 1D-RISM. This is used only if rism1d_dielectric > 0. If you have large molecules, you have to set ~ 20 a.u. .",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "rism1d_dielectric > 0",
              "to == .TRUE."
            ]
          },
          "rawText": "Size of solvent molecules (a.u.) for 1D-RISM. This is used only if rism1d_dielectric > 0. If you have large molecules, you have to set ~ 20 a.u. ."
        },
        "rism1d_nproc": {
          "name": "rism1d_nproc",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "128",
          "description": "Number of processes to calculate 1D-RISM.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Number of processes to calculate 1D-RISM."
        },
        "rism3d_conv_level": {
          "name": "rism3d_conv_level",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.1 if laue_both_hands == .FALSE. .AND. lgcscf == .FALSE.; 0.3 if laue_both_hands == .FALSE. .AND. lgcscf == .TRUE.; 0.5 if laue_both_hands == .TRUE.",
          "description": "Convergence level of 3D-RISM. Convergence level is 'low'. Convergence threshold of 3D-RISM is greater than rism3d_conv_thr , when estimated energy error >> conv_thr . The threshold becomes rism3d_conv_thr , when estimated energy error is enough small. Convergence level is 'medium'. Convergence threshold of 3D-RISM is intermediate value between 'low' and 'high', where rism3d_conv_level is mixing rate. Convergence level is 'high'. Convergence threshold of 3D-RISM is always rism3d_conv_thr .",
          "options": [
            "0.0",
            "0.0<x<1.0",
            "1.0",
            "'low'",
            "'medium'",
            "'high'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Convergence level of 3D-RISM. Convergence level is 'low'. Convergence threshold of 3D-RISM is greater than rism3d_conv_thr , when estimated energy error >> conv_thr . The threshold becomes rism3d_conv_thr , when estimated energy error is enough small. Convergence level is 'medium'. Convergence threshold of 3D-RISM is intermediate value between 'low' and 'high', where rism3d_conv_level is mixing rate. Convergence level is 'high'. Convergence threshold of 3D-RISM is always rism3d_conv_thr ."
        },
        "rism3d_planar_average": {
          "name": "rism3d_planar_average",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": null,
          "description": "If .TRUE., planar averages of solvent densities and potentials are calculated and written to 'prefix.rism1'. For 3D-RISM, default is .FALSE. For Laue-RISM, default is .TRUE.",
          "options": [
            "'prefix.rism1'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE., planar averages of solvent densities and potentials are calculated and written to 'prefix.rism1'. For 3D-RISM, default is .FALSE. For Laue-RISM, default is .TRUE."
        },
        "laue_nfit": {
          "name": "laue_nfit",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Integer",
          "default": "4",
          "description": "The number of z-grid points for the polynomial fit along the cell edge. This is only for Laue-RISM.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The number of z-grid points for the polynomial fit along the cell edge. This is only for Laue-RISM."
        },
        "laue_expand_right": {
          "name": "laue_expand_right",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "-1.0",
          "description": "If positive value, set the ending position offset [in a.u.] of the solvent region on right-hand side of the unit cell, measured relative to the unit cell edge. (the solvent region ends at z = + [L_z/2 + laue_expand_right ].) This is only for Laue-RISM.",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If positive value, set the ending position offset [in a.u.] of the solvent region on right-hand side of the unit cell, measured relative to the unit cell edge. (the solvent region ends at z = + [L_z/2 + laue_expand_right ].) This is only for Laue-RISM."
        },
        "laue_expand_left": {
          "name": "laue_expand_left",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "-1.0",
          "description": "If positive value, set the ending position offset [in a.u.] of the solvent region on left-hand side of the unit cell, measured relative to the unit cell edge. (the solvent region ends at z = - [L_z/2 + laue_expand_left ].) This is only for Laue-RISM.",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If positive value, set the ending position offset [in a.u.] of the solvent region on left-hand side of the unit cell, measured relative to the unit cell edge. (the solvent region ends at z = - [L_z/2 + laue_expand_left ].) This is only for Laue-RISM."
        },
        "laue_starting_right": {
          "name": "laue_starting_right",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.0",
          "description": "Set the starting position [in a.u.] of the solvent region on right-hand side of the unit cell. Then the solvent region is defined as [ laue_starting_right , L_z/2 + laue_expand_right ], where distribution functions are finite. This is only for Laue-RISM.",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Set the starting position [in a.u.] of the solvent region on right-hand side of the unit cell. Then the solvent region is defined as [ laue_starting_right , L_z/2 + laue_expand_right ], where distribution functions are finite. This is only for Laue-RISM."
        },
        "laue_starting_left": {
          "name": "laue_starting_left",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.0",
          "description": "Set the starting position [in a.u.] of the solvent region on left-hand side of the unit cell. Then the solvent region is defined as [ -L_z/2 - laue_expand_left , laue_starting_left ], where distribution functions are finite. This is only for Laue-RISM.",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Set the starting position [in a.u.] of the solvent region on left-hand side of the unit cell. Then the solvent region is defined as [ -L_z/2 - laue_expand_left , laue_starting_left ], where distribution functions are finite. This is only for Laue-RISM."
        },
        "laue_buffer_right": {
          "name": "laue_buffer_right",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "8.0 if laue_expand_right > 0.0; -1.0 if laue_expand_right <= 0.0",
          "description": "If positive value, set the buffering length [in a.u.] of the solvent region on right-hand side of the unit cell. Then correlation functions are defined inside of [ laue_starting_right - laue_buffer_right , L_z/2 + laue_expand_right ]. This is only for Laue-RISM.",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If positive value, set the buffering length [in a.u.] of the solvent region on right-hand side of the unit cell. Then correlation functions are defined inside of [ laue_starting_right - laue_buffer_right , L_z/2 + laue_expand_right ]. This is only for Laue-RISM."
        },
        "laue_buffer_left": {
          "name": "laue_buffer_left",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "8.0 if laue_expand_left > 0.0; -1.0 if laue_expand_left <= 0.0",
          "description": "If positive value, set the buffering length [in a.u.] of the solvent region on left-hand side of the unit cell. Then correlation functions are defined inside of [ -L_z/2 - laue_expand_left , laue_starting_left + laue_buffer_left ]. This is only for Laue-RISM.",
          "options": [],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If positive value, set the buffering length [in a.u.] of the solvent region on left-hand side of the unit cell. Then correlation functions are defined inside of [ -L_z/2 - laue_expand_left , laue_starting_left + laue_buffer_left ]. This is only for Laue-RISM."
        },
        "laue_both_hands": {
          "name": "laue_both_hands",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE., you can set different densities to the solvent regions of right-hand side and left-hand side. See SOLVENTS card.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE., you can set different densities to the solvent regions of right-hand side and left-hand side. See SOLVENTS card."
        },
        "laue_wall": {
          "name": "laue_wall",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "String",
          "default": "'auto'",
          "description": "Set the repulsive wall with (1/r)^12 term of Lennard-Jones potential. This is only for Laue-RISM. The repulsive wall is not defined. The repulsive wall is defined, whose edge position is set automatically. One does not have to set laue_wall_z (the edge position). The repulsive wall is defined, whose edge position is set manually. One have to set laue_wall_z (the edge position).",
          "options": [
            "'none'",
            "'auto'",
            "'manual'"
          ],
          "units": "1/r",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Set the repulsive wall with (1/r)^12 term of Lennard-Jones potential. This is only for Laue-RISM. The repulsive wall is not defined. The repulsive wall is defined, whose edge position is set automatically. One does not have to set laue_wall_z (the edge position). The repulsive wall is defined, whose edge position is set manually. One have to set laue_wall_z (the edge position)."
        },
        "laue_wall_z": {
          "name": "laue_wall_z",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.0",
          "description": "Set the edge position [in a.u.] of the repulsive wall. If laue_expand_right > 0.0, the repulsive wall is defined on [ -inf , laue_wall_z ]. If laue_expand_left > 0.0, the repulsive wall is defined on [ laue_wall_z , inf ]. This is only for Laue-RISM and laue_wall == 'manual' .",
          "options": [
            "'manual'"
          ],
          "units": "a.u.",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "laue_expand_right > 0",
              "laue_expand_left > 0"
            ]
          },
          "rawText": "Set the edge position [in a.u.] of the repulsive wall. If laue_expand_right > 0.0, the repulsive wall is defined on [ -inf , laue_wall_z ]. If laue_expand_left > 0.0, the repulsive wall is defined on [ laue_wall_z , inf ]. This is only for Laue-RISM and laue_wall == 'manual' ."
        },
        "laue_wall_rho": {
          "name": "laue_wall_rho",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.01",
          "description": "The density (1/bohr^3) of the repulsive wall. This is only for Laue-RISM and laue_wall /= 'none' .",
          "options": [
            "'none'"
          ],
          "units": "1/bohr^3",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The density (1/bohr^3) of the repulsive wall. This is only for Laue-RISM and laue_wall /= 'none' ."
        },
        "laue_wall_epsilon": {
          "name": "laue_wall_epsilon",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "0.1",
          "description": "The Lennard-Jones potential of the repulsive wall. Here, you can set the parameter 'epsilon' (kcal/mol). This is only for Laue-RISM and laue_wall /= 'none' .",
          "options": [
            "'epsilon'",
            "'none'"
          ],
          "units": "kcal/mol",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The Lennard-Jones potential of the repulsive wall. Here, you can set the parameter 'epsilon' (kcal/mol). This is only for Laue-RISM and laue_wall /= 'none' ."
        },
        "laue_wall_sigma": {
          "name": "laue_wall_sigma",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Real",
          "default": "4.0",
          "description": "The Lennard-Jones potential of the repulsive wall. Here, you can set the parameter 'sigma' (Angstrom). This is only for Laue-RISM and laue_wall /= 'none' .",
          "options": [
            "'sigma'",
            "'none'"
          ],
          "units": "angstrom",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The Lennard-Jones potential of the repulsive wall. Here, you can set the parameter 'sigma' (Angstrom). This is only for Laue-RISM and laue_wall /= 'none' ."
        },
        "laue_wall_lj6": {
          "name": "laue_wall_lj6",
          "section": "& RISM",
          "sectionType": "namelist",
          "type": "Logical",
          "default": ".FALSE.",
          "description": "If .TRUE., the attractive term -(1/r)^6 of Lennard-Jones potential is added. This is only for Laue-RISM and laue_wall /= 'none' .",
          "options": [
            "'none'"
          ],
          "units": "1/r",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "If .TRUE., the attractive term -(1/r)^6 of Lennard-Jones potential is added. This is only for Laue-RISM and laue_wall /= 'none' ."
        }
      }
    },
    "ATOMIC_SPECIES": {
      "sectionType": "card",
      "variables": {
        "X": {
          "name": "X",
          "section": "ATOMIC_SPECIES",
          "sectionType": "card",
          "type": "String",
          "default": null,
          "description": "label of the atom. Acceptable syntax: chemical symbol X (1 or 2 characters, case-insensitive) or chemical symbol plus a number or a letter, as in \"Xn\" (e.g. Fe1) or \"X_*\" or \"X-*\" (e.g. C1, C_h; max total length cannot exceed 3 characters)",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "label of the atom. Acceptable syntax: chemical symbol X (1 or 2 characters, case-insensitive) or chemical symbol plus a number or a letter, as in \"Xn\" (e.g. Fe1) or \"X_*\" or \"X-*\" (e.g. C1, C_h; max total length cannot exceed 3 characters)"
        },
        "Mass_X": {
          "name": "Mass_X",
          "section": "ATOMIC_SPECIES",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "mass of the atomic species [amu: mass of C = 12] Used only when performing Molecular Dynamics run or structural optimization runs using Damped MD. Not actually used in all other cases (but stored in data files, so phonon calculations will use these values unless other values are provided)",
          "options": [],
          "units": "all",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "mass of the atomic species [amu: mass of C = 12] Used only when performing Molecular Dynamics run or structural optimization runs using Damped MD. Not actually used in all other cases (but stored in data files, so phonon calculations will use these values unless other values are provided)"
        },
        "PseudoPot_X": {
          "name": "PseudoPot_X",
          "section": "ATOMIC_SPECIES",
          "sectionType": "card",
          "type": "String",
          "default": null,
          "description": "File containing PP for this species. The pseudopotential file is assumed to be in the new UPF format. If it doesn't work, the pseudopotential format is determined by the file name: *.vdb or *.van Vanderbilt US pseudopotential code *.RRKJ3 Andrea Dal Corso's code (old format) none of the above old PWscf norm-conserving format",
          "options": [
            "'t work, the pseudopotential format is determined by the file name: *.vdb or *.van Vanderbilt US pseudopotential code *.RRKJ3 Andrea Dal Corso'"
          ],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "File containing PP for this species. The pseudopotential file is assumed to be in the new UPF format. If it doesn't work, the pseudopotential format is determined by the file name: *.vdb or *.van Vanderbilt US pseudopotential code *.RRKJ3 Andrea Dal Corso's code (old format) none of the above old PWscf norm-conserving format"
        }
      }
    },
    "ATOMIC_POSITIONS": {
      "sectionType": "card",
      "variables": {
        "X": {
          "name": "X",
          "section": "ATOMIC_POSITIONS",
          "sectionType": "card",
          "type": "String",
          "default": null,
          "description": "label of the atom as specified in ATOMIC_SPECIES",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "label of the atom as specified in ATOMIC_SPECIES"
        },
        "x , y , z": {
          "name": "x , y , z",
          "section": "ATOMIC_POSITIONS",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "atomic positions NOTE: each atomic coordinate can also be specified as a simple algebraic expression. To be interpreted correctly expression must NOT contain any blank space and must NOT start with a \"+\" sign. The available expressions are: + (plus), - (minus), / (division), * (multiplication), ^ (power) All numerical constants included are considered as double-precision numbers; i.e. 1/2 is 0.5, not zero. Other functions, such as sin, sqrt or exp are not available, although sqrt can be replaced with ^(1/2). Example: C 1/3 1/2*3^(-1/2) 0 is equivalent to C 0.333333 0.288675 0.000000 Please note that this feature is NOT supported by XCrysDen (which will display a wrong structure, or nothing at all). When atomic positions are of type crystal_sg coordinates can be given in the following four forms (Wyckoff positions): C 1a C 8g x C 24m x y C 48n x y z The first form must be used when the Wyckoff letter determines uniquely all three coordinates, forms 2,3,4 when the Wyckoff letter and 1,2,3 coordinates respectively are needed. The forms: C 8g x x x C 24m x x y are not allowed, but C x x x C x x y C x y z are correct.",
          "options": [],
          "units": "plus",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "atomic positions NOTE: each atomic coordinate can also be specified as a simple algebraic expression. To be interpreted correctly expression must NOT contain any blank space and must NOT start with a \"+\" sign. The available expressions are: + (plus), - (minus), / (division), * (multiplication), ^ (power) All numerical constants included are considered as double-precision numbers; i.e. 1/2 is 0.5, not zero. Other functions, such as sin, sqrt or exp are not available, although sqrt can be replaced with ^(1/2). Example: C 1/3 1/2*3^(-1/2) 0 is equivalent to C 0.333333 0.288675 0.000000 Please note that this feature is NOT supported by XCrysDen (which will display a wrong structure, or nothing at all). When atomic positions are of type crystal_sg coordinates can be given in the following four forms (Wyckoff positions): C 1a C 8g x C 24m x y C 48n x y z The first form must be used when the Wyckoff letter determines uniquely all three coordinates, forms 2,3,4 when the Wyckoff letter and 1,2,3 coordinates respectively are needed. The forms: C 8g x x x C 24m x x y are not allowed, but C x x x C x x y C x y z are correct."
        },
        "if_pos(1) , if_pos(2) , if_pos(3)": {
          "name": "if_pos(1) , if_pos(2) , if_pos(3)",
          "section": "ATOMIC_POSITIONS",
          "sectionType": "card",
          "type": "Array",
          "default": "1",
          "description": "component i of the force for this atom is multiplied by if_pos(i), which must be either 0 or 1. Used to keep selected atoms and/or selected components fixed in MD dynamics or structural optimization run. With crystal_sg atomic coordinates the constraints are copied in all equivalent atoms.",
          "options": [],
          "units": "i",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "component i of the force for this atom is multiplied by if_pos(i), which must be either 0 or 1. Used to keep selected atoms and/or selected components fixed in MD dynamics or structural optimization run. With crystal_sg atomic coordinates the constraints are copied in all equivalent atoms."
        }
      },
      "cardOptions": {
        "options": [
          "alat",
          "bohr",
          "angstrom",
          "crystal",
          "crystal_sg"
        ],
        "default": "(DEPRECATED) alat"
      }
    },
    "K_POINTS": {
      "sectionType": "card",
      "variables": {
        "nks": {
          "name": "nks",
          "section": "K_POINTS",
          "sectionType": "card",
          "type": "Integer",
          "default": null,
          "description": "Number of supplied special k-points.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Number of supplied special k-points."
        },
        "xk_x , xk_y , xk_z , wk": {
          "name": "xk_x , xk_y , xk_z , wk",
          "section": "K_POINTS",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "Special k-points (xk_x/y/z) in the irreducible Brillouin Zone (IBZ) of the lattice (with all symmetries) and weights (wk) See the literature for lists of special points and the corresponding weights. If the symmetry is lower than the full symmetry of the lattice, additional points with appropriate weights are generated. Notice that such procedure assumes that ONLY k-points in the IBZ are provided in input In a non-scf calculation, weights do not affect the results. If you just need eigenvalues and eigenvectors (for instance, for a band-structure plot), weights can be set to any value (for instance all equal to 1).",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "be == .TRUE."
            ]
          },
          "rawText": "Special k-points (xk_x/y/z) in the irreducible Brillouin Zone (IBZ) of the lattice (with all symmetries) and weights (wk) See the literature for lists of special points and the corresponding weights. If the symmetry is lower than the full symmetry of the lattice, additional points with appropriate weights are generated. Notice that such procedure assumes that ONLY k-points in the IBZ are provided in input In a non-scf calculation, weights do not affect the results. If you just need eigenvalues and eigenvectors (for instance, for a band-structure plot), weights can be set to any value (for instance all equal to 1)."
        },
        "nk1, nk2, nk3": {
          "name": "nk1, nk2, nk3",
          "section": "K_POINTS",
          "sectionType": "card",
          "type": "Integer",
          "default": null,
          "description": "These parameters specify the k-point grid (nk1 x nk2 x nk3) as in Monkhorst-Pack grids.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "These parameters specify the k-point grid (nk1 x nk2 x nk3) as in Monkhorst-Pack grids."
        },
        "sk1, sk2, sk3": {
          "name": "sk1, sk2, sk3",
          "section": "K_POINTS",
          "sectionType": "card",
          "type": "Integer",
          "default": null,
          "description": "The grid offsets; sk1, sk2, sk3 must be 0 ( no offset ) or 1 ( grid displaced by half a grid step in the corresponding direction ).",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "The grid offsets; sk1, sk2, sk3 must be 0 ( no offset ) or 1 ( grid displaced by half a grid step in the corresponding direction )."
        }
      },
      "cardOptions": {
        "options": [
          "tpiba",
          "automatic",
          "crystal",
          "gamma",
          "tpiba_b",
          "crystal_b",
          "tpiba_c",
          "crystal_c"
        ],
        "default": "tbipa"
      }
    },
    "ADDITIONAL_K_POINTS": {
      "sectionType": "card",
      "variables": {
        "nks_add": {
          "name": "nks_add",
          "section": "ADDITIONAL_K_POINTS",
          "sectionType": "card",
          "type": "Integer",
          "default": null,
          "description": "Number of supplied \"additional\" k-points.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Number of supplied \"additional\" k-points."
        },
        "k_x , k_y , k_z , wk_": {
          "name": "k_x , k_y , k_z , wk_",
          "section": "ADDITIONAL_K_POINTS",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "for the respective explanation, see the xk_x , xk_y , xk_z , wk",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "for the respective explanation, see the xk_x , xk_y , xk_z , wk"
        }
      },
      "cardOptions": {
        "options": [
          "tpiba",
          "crystal",
          "tpiba_b",
          "crystal_b",
          "tpiba_c",
          "crystal_c"
        ],
        "default": "tbipa"
      }
    },
    "CELL_PARAMETERS": {
      "sectionType": "card",
      "variables": {
        "v1 , v2 , v3": {
          "name": "v1 , v2 , v3",
          "section": "CELL_PARAMETERS",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "Crystal lattice vectors (in cartesian axis): v1(1) v1(2) v1(3) ... 1st lattice vector v2(1) v2(2) v2(3) ... 2nd lattice vector v3(1) v3(2) v3(3) ... 3rd lattice vector",
          "options": [],
          "units": "cartesian",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Crystal lattice vectors (in cartesian axis): v1(1) v1(2) v1(3) ... 1st lattice vector v2(1) v2(2) v2(3) ... 2nd lattice vector v3(1) v3(2) v3(3) ... 3rd lattice vector"
        }
      },
      "cardOptions": {
        "options": [
          "alat",
          "bohr",
          "angstrom"
        ],
        "default": null
      }
    },
    "CONSTRAINTS": {
      "sectionType": "card",
      "variables": {
        "nconstr": {
          "name": "nconstr",
          "section": "CONSTRAINTS",
          "sectionType": "card",
          "type": "Integer",
          "default": null,
          "description": "Number of constraints.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Number of constraints."
        },
        "constr_tol": {
          "name": "constr_tol",
          "section": "CONSTRAINTS",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "Tolerance for keeping the constraints satisfied.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Tolerance for keeping the constraints satisfied."
        },
        "constr_type": {
          "name": "constr_type",
          "section": "CONSTRAINTS",
          "sectionType": "card",
          "type": "String",
          "default": null,
          "description": "Type of constraint : constraint on global coordination-number, i.e. the average number of atoms of type B surrounding the atoms of type A. The coordination is defined by using a Fermi-Dirac. (four indexes must be specified). constraint on local coordination-number, i.e. the average number of atoms of type A surrounding a specific atom. The coordination is defined by using a Fermi-Dirac. (four indexes must be specified). constraint on interatomic distance (two atom indexes must be specified). constraint on planar angle (three atom indexes must be specified). constraint on torsional angle (four atom indexes must be specified). constraint on the projection onto a given direction of the vector defined by the position of one atom minus the center of mass of the others. G. Roma, J.P. Crocombette: J. Nucl. Mater. 403, 32 (2010), doi:10.1016/j.jnucmat.2010.06.001 (experimental) add a potential wall at the origin normal to the the z-axis.",
          "options": [
            "'type_coord'",
            "'atom_coord'",
            "'distance'",
            "'planar_angle'",
            "'torsional_angle'",
            "'bennett_proj'",
            "'potential_wall'"
          ],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Type of constraint : constraint on global coordination-number, i.e. the average number of atoms of type B surrounding the atoms of type A. The coordination is defined by using a Fermi-Dirac. (four indexes must be specified). constraint on local coordination-number, i.e. the average number of atoms of type A surrounding a specific atom. The coordination is defined by using a Fermi-Dirac. (four indexes must be specified). constraint on interatomic distance (two atom indexes must be specified). constraint on planar angle (three atom indexes must be specified). constraint on torsional angle (four atom indexes must be specified). constraint on the projection onto a given direction of the vector defined by the position of one atom minus the center of mass of the others. G. Roma, J.P. Crocombette: J. Nucl. Mater. 403, 32 (2010), doi:10.1016/j.jnucmat.2010.06.001 (experimental) add a potential wall at the origin normal to the the z-axis."
        },
        "constr_target": {
          "name": "constr_target",
          "section": "CONSTRAINTS",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "Target for the constrain ( angles are specified in degrees ). This variable is optional.",
          "options": [],
          "units": "degrees",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Target for the constrain ( angles are specified in degrees ). This variable is optional."
        }
      }
    },
    "OCCUPATIONS": {
      "sectionType": "card",
      "variables": {
        "f_inp1": {
          "name": "f_inp1",
          "section": "OCCUPATIONS",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "Occupations of individual states (MAX 10 PER ROW). For spin-polarized calculations, these are majority spin states.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Occupations of individual states (MAX 10 PER ROW). For spin-polarized calculations, these are majority spin states."
        },
        "f_inp2": {
          "name": "f_inp2",
          "section": "OCCUPATIONS",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "Occupations of minority spin states (MAX 10 PER ROW) To be specified only for spin-polarized calculations.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "Occupations of minority spin states (MAX 10 PER ROW) To be specified only for spin-polarized calculations."
        }
      }
    },
    "ATOMIC_VELOCITIES": {
      "sectionType": "card",
      "variables": {
        "V": {
          "name": "V",
          "section": "ATOMIC_VELOCITIES",
          "sectionType": "card",
          "type": "String",
          "default": null,
          "description": "label of the atom as specified in ATOMIC_SPECIES",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "label of the atom as specified in ATOMIC_SPECIES"
        },
        "vx , vy , vz": {
          "name": "vx , vy , vz",
          "section": "ATOMIC_VELOCITIES",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "atomic velocities along x y and z direction",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "atomic velocities along x y and z direction"
        }
      }
    },
    "ATOMIC_FORCES": {
      "sectionType": "card",
      "variables": {
        "X": {
          "name": "X",
          "section": "ATOMIC_FORCES",
          "sectionType": "card",
          "type": "String",
          "default": null,
          "description": "label of the atom as specified in ATOMIC_SPECIES",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "label of the atom as specified in ATOMIC_SPECIES"
        },
        "fx , fy , fz": {
          "name": "fx , fy , fz",
          "section": "ATOMIC_FORCES",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "external force on atom X (cartesian components, Ry/a.u. units)",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "external force on atom X (cartesian components, Ry/a.u. units)"
        }
      }
    },
    "SOLVENTS": {
      "sectionType": "card",
      "variables": {
        "X": {
          "name": "X",
          "section": "SOLVENTS",
          "sectionType": "card",
          "type": "String",
          "default": null,
          "description": "label of the solvent molecule.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "label of the solvent molecule."
        },
        "Density": {
          "name": "Density",
          "section": "SOLVENTS",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "density of the solvent molecule. if not positive value is set, density is read from MOL-file.",
          "options": [],
          "units": null,
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "is == .TRUE."
            ]
          },
          "rawText": "density of the solvent molecule. if not positive value is set, density is read from MOL-file."
        },
        "Molecule": {
          "name": "Molecule",
          "section": "SOLVENTS",
          "sectionType": "card",
          "type": "String",
          "default": null,
          "description": "MOL-file of the solvent molecule. in the MOL-file, molecular structure and some other data are written.",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": null,
          "rawText": "MOL-file of the solvent molecule. in the MOL-file, molecular structure and some other data are written."
        },
        "Density_Left": {
          "name": "Density_Left",
          "section": "SOLVENTS",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "density of the solvent molecule in the left-hand side. if not positive value is set, density is read from MOL-file.",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "is == .TRUE."
            ]
          },
          "rawText": "density of the solvent molecule in the left-hand side. if not positive value is set, density is read from MOL-file."
        },
        "Density_Right": {
          "name": "Density_Right",
          "section": "SOLVENTS",
          "sectionType": "card",
          "type": "Real",
          "default": null,
          "description": "density of the solvent molecule in the right-hand side. if not positive value is set, density is read from MOL-file.",
          "options": [],
          "units": "the",
          "range": null,
          "example": null,
          "since": null,
          "notes": null,
          "constraints": {
            "requires": [],
            "conflicts": [],
            "implies": [],
            "validWhen": [
              "is == .TRUE."
            ]
          },
          "rawText": "density of the solvent molecule in the right-hand side. if not positive value is set, density is read from MOL-file."
        }
      },
      "cardOptions": {
        "options": [
          "1/cell",
          "mol/L",
          "g/cm^3"
        ],
        "default": null
      }
    },
    "HUBBARD": {
      "sectionType": "card",
      "variables": {},
      "cardOptions": {
        "options": [
          "atomic",
          "ortho-atomic",
          "norm-atomic",
          "wf",
          "pseudo"
        ],
        "default": null
      }
    }
  }
}